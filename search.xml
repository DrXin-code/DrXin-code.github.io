<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>哪吒之魔童闹海</title>
      <link href="/2025/02/04/%E5%93%AA%E5%90%92/"/>
      <url>/2025/02/04/%E5%93%AA%E5%90%92/</url>
      
        <content type="html"><![CDATA[<h1 id="《哪吒之魔童闹海》观后感"><a href="#《哪吒之魔童闹海》观后感" class="headerlink" title="《哪吒之魔童闹海》观后感"></a>《哪吒之魔童闹海》观后感</h1><!--观影时间：2025年2月4日蛇年春节正月初七--><!--自我评分：&#9733;&#9733;&#9733;&#9733;&#9733;--><img src="https://s2.loli.net/2025/02/04/DaRq3ACkd5mXiJp.png" alt="image-20250204235127400" style="zoom:50%;" /><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>剧情并无任何槽点，首先达到了国产电影很难做到的‘’双线流畅叙事‘’，电影以哪吒协助复活敖丙为主线，以妖仙之怨为暗线，对剧中各个人物开枝散叶般展开叙述，塑造了很多丰满的人物比如全家人的希望——申公豹，一心为家的龙王等等。同时剧情跌宕起伏，翻转虽在意料之外又在情理之中，一些伏笔比如🦌童对哪吒怀疑、对申公豹父亲冷漠，还有申公豹视作珍宝的丹药仙族竟然有一缸，这些都暗示仙族并不是完全正义的，在后面的反转之后让人更觉得世界上并没有完全的正义也没有完全的邪恶，正如申公豹所说：‘’人心中的成见是一座大山‘’，其实在看电影的时候我们也成了‘’大仙‘’。</p><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a><strong>人物</strong></h2><ul><li>哪吒：依旧不受拘束，相比第一部人物性格中更多了一些对于父母的依赖，懂得对朋友报恩，少了些无厘头的暴虐，这也算一种成长，<del>另外就是最后重塑肉身的样子有一些中二哈哈哈哈哈还是之前的魔童有特点，那老黑眼圈～😈</del>让我不禁和黑神话联系起来，最近几年冲破束缚、对抗权威的主旋律很受大家欢迎。</li><li>敖丙：规规矩矩的，感觉就是为了衬托哪吒而塑造的角色，有一些娘化了，刻意炒cp的嫌疑，无感。</li><li>申公豹：这也是第二部中被大众讨论最多的角色，表面的邪恶其实是为了反抗所谓的仙族正义，他是整个山头的骄傲，成了仙族弟子后父亲变得生龙活虎、走路都自信，七山八头的妖怪都来请教拜师，也是弟弟心中的榜样，人物性格可谓是极其丰满，在中间大家都以为他失去理智屠城后没想到他选择了理性思考，对抗仙族最后以身赴死👍</li><li>哪吒父母：没什么好说的，梦爸梦妈，即使是编剧明刀🔪我还是不自觉流下来了眼泪哈哈哈哈。</li><li>仙族：和黑神话里面的仙族几乎一模一样，表面正义自谓正道，实则最后都是妖怪化身，所以正说明实力决定一切，落后就要挨打！和前几天看的《唐探1900》一样，只有强大的一方能决定正义是什么，弱小的就只配臣服，不要一味的埋冤不公，逶迤求全像晚清政府、早期龙王、黑神话里面的牛魔王，应该像申公豹、觉醒的龙王、革命先烈一样睁眼看世界，剥削是无止境的，我们要拿起枪杆子去革命去战斗！枪杆子里出政权⚖️</li></ul><h2 id="画面"><a href="#画面" class="headerlink" title="画面"></a><strong>画面</strong></h2><p>首先我要拉踩一下，前几年的《深海》画面确实顶级，全部都是粒子特效，可是为什么没有取得成功呢，因为它的画面配不上它的剧情。纵观中国票房排行榜，能成功者画面剧情都是缺一不可的，回顾近几年的观影体验，令我震撼的有《流浪地球1&amp;2》、漫威系列，国产动漫能做到如此良心实在配得上它七天47亿的票房，就像网友说感觉饺子导演把第一部赚的钱全都投在第二部了哈哈哈哈哈。之前就看宣发，特效导演把每个细节都渲染到位，比如大战时候的小兵每个都忙自己的，海妖挣脱时候每根锁链都一一渲染，大战时候的粒子特效，重塑肉身的惊艳，美到每一帧都能当做壁纸的程度，实在令我词穷，看电影时候每一刻都在感慨这都是人干出来的呀，这得有多费钱多费精力，这下显得同一期的《封神2》的三毛钱特效羞愧难当，同样是人同样是第二部，有些导演是真黑啊，现在都观众已经不是之前的了不会被宣发或者流量演员蒙蔽双眼。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>刚看完哪吒，又看见炼丹，脑海里马上浮现出看过的书和影视剧中一些炼丹剧情</strong>：</p><ol><li>龙族三 绘梨衣被炼，当时高三抱着书在厕所里哭了好久 </li><li>黑神话 四妹被炼，也是感慨良久</li><li>小鱼儿与花无缺 一部老剧不知道畔u看过没，小仙女当时我觉得真的太好看了，童年女神，被炼了之后真的留下来童年阴影</li></ol>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观后感，电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机病毒</title>
      <link href="/2025/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92/"/>
      <url>/2025/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>计算机病毒是指<strong>编制</strong>或者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组<strong>计算机指令</strong>或者程序代码</p><ul><li>自我复制-主动传染</li><li>被动传染-夹杂文件打开</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol><li>可执行性（程序性）<ul><li><strong>基本特征</strong>，最基本的一种表现形式</li><li><strong>程序性</strong>决定了计算机病毒的<strong>可防治性</strong>、<strong>可清除性</strong></li></ul></li><li>传染性<ul><li>是判别一个程序是否为计算机病毒的<strong>首要条件</strong></li><li>决定了计算机病毒的<strong>可判断性</strong>。</li></ul></li><li>非授权性</li><li>隐蔽性<ul><li>传染方式的隐蔽性</li><li>病毒程序存在的隐蔽</li></ul></li><li>潜伏性</li><li>可触发性</li><li>破坏性</li><li>主动性</li><li>针对性</li><li>衍生性<ul><li>导致产生变体病毒的必然原因</li></ul></li><li>寄生性(依附性)</li><li>不可预见性</li><li>诱惑欺骗性</li><li>持久性</li></ol><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li>人为制造的程序</li><li>本质特点：无限重复执行 or 复制</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>破坏能力<ul><li>无害型：占用内存</li><li>无危险型</li><li>危险型</li><li>非常危险性</li></ul></li><li>破坏情况<ul><li>良性病毒</li><li>恶性病毒</li></ul></li><li>自身算法<ul><li>伴随型病毒：<strong>不改变</strong>文件本身，根据算法产生文件的伴随体：.exe &amp; .com</li><li>蠕虫型病毒：<strong>通过计算机网络传播</strong>，<strong>不改变</strong>文件和资料信息</li><li>寄生型：1&amp;2的补集</li><li>练习型</li><li>变形病毒（幽灵病毒）：一般由一段混有无关指令的解码算法和被变化过的病毒体组成</li></ul></li><li>链接方式<ul><li>源码型病毒：插入高级语言源程序，经编译成为合法程序</li><li>嵌入型病毒（入侵型病毒）：主体</li><li>外壳（Shell）型病毒：首部或者尾部</li><li>译码型病毒：宏、脚本</li><li>OS型病毒</li></ul></li><li>传播媒介<ul><li>单机病毒：磁盘、U盘、光盘、软盘-&gt;硬盘-&gt;其他软盘</li><li>网络病毒</li></ul></li><li>寄生对象<ul><li>引导型</li><li>文件型</li><li>混合型</li></ul></li></ol><h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p><img src="https://s2.loli.net/2024/04/15/BvTWR3Y6y7Ucfhi.png" alt="image-20240415160347841"></p><h4 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h4><ol><li><p>独立exe：主程序+引导程序</p><ul><li>主程序：建立后收集处于同一网络的其他计算机信息，远程建立引导程序</li><li>引导程序：将蠕虫带入它所感染的每一台计算机中</li></ul></li><li><p>并不需要链入宿主程序达到自我复制的目的</p></li><li><p>工作流程</p><p><img src="https://s2.loli.net/2024/04/15/JCGL5bfEostKXwr.png" alt="image-20240415161422004"></p></li><li><p>特性</p><ul><li>传染方式多：不同程序、不同协议</li><li>传播速度快</li><li>清除难度大</li><li>破坏性强</li></ul></li></ol><h4 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h4><ol><li><strong>表面上</strong>是有用的软件、实际目的却是危害计算机安全并导致严重破坏的<strong>计算机程序</strong>，是一种在<strong>远程计算机之间建立连接</strong>，使远程计算机能<strong>通过网络控制</strong>本地计算机的非法程序。木马本身<strong>不能传播</strong>自身。</li><li><strong>客户端</strong>+<strong>服务器</strong>  两个程序<ul><li>客户端：攻击者用于远程控制被攻击者<strong>的程序</strong></li><li>服务器端：被攻击者计算机中的木马程序</li></ul></li></ol><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ol><li><p>三元组命名规则：前缀+病毒名+后缀</p><ul><li>前缀：发作的os、病毒类型。DOS下的病毒一般没有前缀</li><li>病毒名：名称以及家族</li><li>后缀：区分改病毒家族中各病毒的不同</li></ul></li><li><p>优先级</p><p>病毒的发现者(或制造者)→病毒的发作症状→病毒的发源地→病毒代码中的特征字符串</p><p><img src="https://s2.loli.net/2024/04/15/pGjyda74rTOx3LM.png" alt="image-20240415162754662"></p></li></ol><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ol><li>蓄意破坏</li><li>偶然性破坏</li><li>附带性破坏</li><li>心理、社会危害</li></ol><p>病毒与计算机故障的异同</p><ol><li><p>相似的硬件故障</p><ul><li>硬件配置</li><li>电源电压</li><li>插件接触不良</li><li>软件驱动故障</li><li>CMOS：BIOS设置不当发生死机</li></ul></li><li><p>相似的软件故障</p><ul><li>出现“Invalid drive specification(非法驱动器号)”：主引导扇区的<strong>分区表参数被破坏</strong>或者磁盘标志55AA被修改</li><li>光盘未格式化：光盘的刻录速度与正在使用的光驱的倍速不匹配</li></ul></li><li><p>区别</p><ul><li>磁盘问题导致软件程序或者文档被破坏</li><li>其他配置不当等问题</li></ul><p><strong>传播途径</strong></p><ul><li>硬件设备：移动+不可移动</li><li>有线网络：Email、BBS</li><li>无线通讯：Message、Bluetooth</li></ul><p><strong>生命周期</strong></p><p>​    程序设计→传播→潜伏（动态静态：是否在内存中）→触发、运行→实施攻击</p></li></ol><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><img src="https://s2.loli.net/2024/04/19/231PgKzGJMHl8TR.png" alt="image-20240419192658569"></p><ul><li><p>FAT区存放簇链，0，1簇为系统所用，簇对应的数据在数据区，第一个用户的簇为2</p></li><li><p>根目录区存放目录以及子目录，目录及文件，倒数6-5为簇号</p><p><img src="https://s2.loli.net/2024/04/19/1QbSLgijWhM8ItY.png" alt="image-20240419193014254"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安实验</title>
      <link href="/2025/01/24/%E4%BF%A1%E5%AE%89%E5%AE%9E%E9%AA%8C/"/>
      <url>/2025/01/24/%E4%BF%A1%E5%AE%89%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="信安实验"><a href="#信安实验" class="headerlink" title="信安实验"></a>信安实验</h1><h2 id="模指数"><a href="#模指数" class="headerlink" title="模指数"></a>模指数</h2><ul><li>记住溢出所以要不断进行取余操作</li><li>不要复制粘贴代码</li></ul><h2 id="Eratosthenes筛选法"><a href="#Eratosthenes筛选法" class="headerlink" title="Eratosthenes筛选法"></a>Eratosthenes筛选法</h2><ul><li>构造一个从2 到 sqrt（a）的集合，然后从2开始去掉集合中的倍数，最后看看a是否能整除这个集合中的数字</li><li>memset(res,value,数量) 是从字节开始赋值，所以一般赋值0合适一点，尤其是int型数组</li><li><strong>一定到考虑错误比如小于2以及其他情况的判断！！！！！！</strong></li><li>unsigned 2^32-1&#x3D;&#x3D;4294967295(这是上限) int 2^31 -1</li><li>为了防止计算溢出，采用<strong>unsigned long long</strong> 2^64-1  (long long 2^63-1)   差的都是符号位置</li></ul><h2 id="米勒拉宾素性检测"><a href="#米勒拉宾素性检测" class="headerlink" title="米勒拉宾素性检测"></a>米勒拉宾素性检测</h2><ul><li><strong>判断a的范围</strong>，<strong>1&lt;a&lt;n-1</strong>,1&lt;&#x3D;j&lt;&#x3D;k</li><li>看清上下角标</li><li>pow在std中已经被定义过了</li><li>总共要判断两次</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">miller_rabin_prime_test</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span> || a&gt;=n<span class="number">-1</span>)<span class="comment">//因为a的范围，而且a是un型的变量，所以不能和素数比较，所以要a&gt;=n-1，连负数一起判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> k=<span class="number">0</span>,q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q=(n<span class="number">-1</span>)/<span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>,k));</span><br><span class="line">        <span class="keyword">if</span>(q%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mod_exp</span>(a,q,n)==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;uncertain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mod_exp</span>(a,<span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>,j<span class="number">-1</span>))*q,n)==n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;uncertain&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 对n进行非确定性素性测试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;not_prime&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展欧几里得求逆元"><a href="#扩展欧几里得求逆元" class="headerlink" title="扩展欧几里得求逆元"></a>扩展欧几里得求逆元</h2><ul><li><p>先用欧几里得求出gcd以及x,y</p></li><li><p>然后对x进行非负判断 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x%m+m)%m;</span><br></pre></td></tr></table></figure></li><li><p>注意gcd不是1，即不是互素，要进行判错</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> m,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gcd=<span class="built_in">ex_gcd</span>(m,a%m,y,x);</span><br><span class="line">    y=y-(a/m)*x;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euclid_mod_reverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span> || m&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ex_gcd</span>(a,m,x,y)!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (x%m+m)%m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性同余"><a href="#线性同余" class="headerlink" title="线性同余"></a>线性同余</h2><ul><li>记住唯一的公式即可，注意防止溢出</li></ul><h2 id="BBS"><a href="#BBS" class="headerlink" title="BBS"></a>BBS</h2><ul><li>重点是提取比特序列，奇偶校验位</li><li></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">bbs_rand</span><span class="params">(<span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag!=<span class="number">0</span> &amp;&amp; flag!=<span class="number">1</span> &amp;&amp; flag!=<span class="number">2</span>)<span class="comment">//注意flag是012还是123</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//注意此处的错误判断</span></span><br><span class="line">    <span class="type">int</span> res_1[<span class="number">33</span>],res_2[<span class="number">33</span>],res_3[<span class="number">33</span>];</span><br><span class="line">           <span class="type">int</span> tep=<span class="number">3</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        tep=(tep*tep)%(_p*_q);<span class="comment">//注意只有第一下初始为3</span></span><br><span class="line">        cout&lt;&lt;tep;</span><br><span class="line">        string tep_dec=<span class="built_in">de_2_bn</span>(tep);</span><br><span class="line">        <span class="keyword">if</span>(tep_dec[tep_dec.<span class="built_in">length</span>()<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res_1[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res_1[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">one_in_dec</span>(tep_dec)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res_2[i]=<span class="number">1</span>;</span><br><span class="line">            res_3[i]=<span class="number">0</span>;<span class="comment">//复制粘贴的时候出错误，为了避免得不偿失还是少点复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res_2[i]=<span class="number">0</span>;</span><br><span class="line">            res_3[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>-i)*res_1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>-i)*res_2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>-i)*res_3[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 返回32轮迭代过后的伪随机数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局变量默认值：</span></span><br><span class="line">    <span class="comment">//  p = 11</span></span><br><span class="line">    <span class="comment">//  q = 19</span></span><br><span class="line">    <span class="comment">//  n = p * q</span></span><br><span class="line">    <span class="comment">//  _bbs_seed = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>编译过程的第一个阶段就是预处理阶段。该阶段要完成的任务：</p><p>将#include关键字标示的含有定义的文件（包括文件或头文件）包含到源代码文件中。<br>将#include语句指定的值转换成常量。<br>在代码中调用宏的位置将宏定义转换成代码。<br>根据#if、#elif、#endif包含或排除特定部分的代码<br>     经过预处理阶段之后会形成一系列的.i文件</p><ul><li><p>处理宏定义指令</p><p>将已经定义过的参数变换成宏</p></li><li><p>处理条件编译指令</p></li></ul><p>​防止头文件的重复定义</p><ul><li>扩展头文件包含指令</li></ul><p>​头文件以h结尾</p><p><strong>gcc -E</strong>     <strong>.i文件 1203.</strong></p><p> <strong>生成预处理代码</strong></p><p>参考：<a href="https://blog.csdn.net/LMM1314521/article/details/127431524?ops_request_misc=%7B%22request_id%22:%22170056996616777224456350%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170056996616777224456350&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127431524-null-null.142%5Ev96%5Epc_search_result_base7&utm_term=%E9%A2%84%E5%A4%84%E7%90%86&spm=1018.2226.3001.4187">【精选】什么是预处理_预处理阶段-CSDN博客</a></p><p><a href="https://blog.csdn.net/adminstate/article/details/128438121?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128438121-blog-127431524.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128438121-blog-127431524.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=5">三、编译预处理阶段_scx_link的博客-CSDN博客</a></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><strong>将i文件处理为s文件</strong></p><p><strong>gcc -S</strong>   ** **</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -S demo.i –o demo.s</span><br></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编语言转换成机器语言 生成目标文件 .O    也称 可重定位文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c demo.s -o demo.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li>将各个目标文件组合到一起的过程</li><li>可执行文件windows后缀为.exe，Linux后缀为.out</li></ul><p>链接器将各种.o文件进行合并并生成可执行目标文件，可以被加载到内存中，由系统进行执行。<br>连接目标代码，生成可执行程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ main.o -o main</span><br></pre></td></tr></table></figure><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><ul><li>创建过程</li></ul><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>预处理、编译、汇编和链接是计算机程序的构建过程中的四个主要阶段。它们按照顺序依次执行，最终将高级编程语言的源代码转化为可执行文件。下面是对每个阶段的详细介绍：</p><ol><li><p><strong>预处理（Preprocessing）</strong>：</p><ul><li><strong>任务：</strong> 预处理是在源代码被编译之前的第一步，它主要负责对源代码进行一些文本替换和处理，以生成被编译器进一步处理的中间代码。</li><li><strong>过程：</strong> 预处理器通常会执行以下任务：<ul><li><strong>宏替换：</strong> 展开程序中的宏定义。</li><li><strong>文件包含：</strong> 处理<code>#include</code>指令，将包含的头文件内容插入到源文件中。</li><li><strong>条件编译：</strong> 处理<code>#if</code>、<code>#else</code>、<code>#endif</code>等条件编译指令，根据条件选择性地包含或排除代码。</li><li><strong>注释去除：</strong> 去除注释，将注释后的内容删除。</li></ul></li></ul></li><li><p><strong>编译（Compiling）</strong>：</p><ul><li><strong>任务：</strong> 编译阶段将预处理后的源代码转化为汇编代码，该代码是特定于目标机器架构的低级中间代码。</li><li><strong>过程：</strong> 编译器执行以下关键任务：<ul><li><strong>词法分析：</strong> 将源代码转化为标记（tokens）。</li><li><strong>语法分析：</strong> 构建抽象语法树（Abstract Syntax Tree，AST），检查语法错误。</li><li><strong>语义分析：</strong> 检查语法结构的语义正确性，进行类型检查。</li><li><strong>优化：</strong> 对代码进行一些优化，以提高执行效率。</li><li><strong>代码生成：</strong> 生成与目标机器体系结构相关的汇编代码。</li></ul></li></ul></li><li><p><strong>汇编（Assembling）</strong>：</p><ul><li><strong>任务：</strong> 汇编阶段将编译生成的汇编代码翻译成机器语言指令，生成可重定位的目标文件。</li><li><strong>过程：</strong> 汇编器执行以下主要步骤：<ul><li><strong>符号解析：</strong> 将代码中使用的符号（变量、函数名等）映射到内存地址。</li><li><strong>地址解析：</strong> 为指令生成实际的内存地址。</li><li><strong>生成目标文件：</strong> 将汇编代码转化为目标文件，包含机器语言指令和相关的元信息。</li></ul></li></ul></li><li><p><strong>链接（Linking）</strong>：</p><ul><li><strong>任务：</strong> 链接阶段将多个目标文件和库文件组合成一个可执行文件。</li><li><strong>过程：</strong> 链接器执行以下主要任务：<ul><li><strong>地址解析：</strong> 解析和分配程序中使用的符号的最终内存地址。</li><li><strong>符号解析：</strong> 解决在不同目标文件中定义的符号之间的引用关系。</li><li><strong>重定位：</strong> 调整目标文件中的地址，使得各个目标文件中的地址能够正确地映射到最终的内存地址。</li><li><strong>生成可执行文件：</strong> 将所有目标文件和必要的库文件链接在一起，生成最终的可执行文件。</li></ul></li></ul></li></ol><p>综合来说，这四个阶段协同工作，将高级编程语言的源代码转化为可在计算机上执行的机器语言，并最终生成可执行文件。</p><p>当你在预处理过程中使用了尚未定义的函数时，预处理阶段本身不会报错。这是因为预处理阶段主要处理一些文本替换和条件编译等任务，而不会对代码的语法和语义进行深入检查。</p><p>具体来说，在预处理阶段，如果你使用了某个函数的声明，而该函数的定义在当前文件或包含的头文件中尚未出现，预处理器不会引发错误。预处理器只是简单地展开宏、处理条件编译指令、执行文件包含等操作。</p><h2 id="OPENSSL"><a href="#OPENSSL" class="headerlink" title="OPENSSL"></a>OPENSSL</h2><p><code>man</code> 是一个用于查看 Unix&#x2F;Linux 系统上的手册页面的命令，但是在某些系统上，特别是一些较小或定制化的系统上，可能并没有完整的手册页面。如果你在使用 <code>man</code> 命令时无法查询到 OpenSSL 库函数的手册页面，有几种可能的原因和替代方法：</p><ol><li><p><strong>手册页面不存在：</strong> 确保 OpenSSL 库已经正确安装，并且你的系统支持 OpenSSL 的手册页面。你可以尝试安装 OpenSSL 的手册页面，具体方法可能因系统而异。例如，在基于 Debian 的系统上，你可以运行以下命令安装 OpenSSL 的手册页面：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libssl-doc</span><br></pre></td></tr></table></figure><p> <strong>2.openssl</strong> 安装</p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>BIGNUM *a_ = BN_new()</code> 这行代码在使用 OpenSSL 库中进行大数运算时创建了一个 BIGNUM 对象，其中：</p><ul><li><code>BIGNUM</code> 是 OpenSSL 库中用于表示大整数的数据类型。</li><li><code>BN_new()</code> 是 OpenSSL 提供的函数，用于创建一个新的 BIGNUM 对象。</li></ul><h3 id="模指数-1"><a href="#模指数-1" class="headerlink" title="模指数"></a>模指数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BN_mod_exp</span><span class="params">(BIGNUM *r, BIGNUM *a, <span class="type">const</span> BIGNUM *p, <span class="type">const</span> BIGNUM *m, BN_CTX *ctx)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>返回值是1或者错误返回</p></li><li><p>注意最后一个参数为 BN_CTX_new()</p></li><li><p>最后要释放参数</p></li><li><pre><code class="language-c++">string mod_exp(string a, string e, string m)&#123;    BIGNUM *an,*en,*mn,*res;    an=BN_new();    en=BN_new();    mn=BN_new();    res=BN_new();    BN_dec2bn(&amp;an,a.c_str());    BN_dec2bn(&amp;en,e.c_str());    BN_dec2bn(&amp;mn,m.c_str());    if(BN_mod_exp(res, an, en,mn, BN_CTX_new()))    &#123;        char *result;        result=BN_bn2dec(res);        return result;    &#125;     else    &#123;        return &quot;error&quot;;    &#125;    BN_free(an);    BN_free(en);    BN_free(mn);    BN_free(res);    &#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 逆元</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"> BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,BN_CTX *ctx);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>返回值是大数指针或者错误返回</p></li><li><p>注意最后一个参数为 BN_CTX_new()</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">mod_inverse</span><span class="params">(string a, string m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BIGNUM *an,*mn,*res;</span><br><span class="line">    an=<span class="built_in">BN_new</span>();</span><br><span class="line">    mn=<span class="built_in">BN_new</span>();</span><br><span class="line">    res=<span class="built_in">BN_new</span>();</span><br><span class="line">    <span class="built_in">BN_dec2bn</span>(&amp;an,a.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">BN_dec2bn</span>(&amp;mn,m.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">BN_mod_inverse</span>(res, an, mn,<span class="built_in">BN_CTX_new</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * result;</span><br><span class="line">        result=<span class="built_in">BN_bn2dec</span>(res);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">BN_free</span>(an);</span><br><span class="line">    <span class="built_in">BN_free</span>(en);</span><br><span class="line">    <span class="built_in">BN_free</span>(mn);</span><br><span class="line">    <span class="built_in">BN_free</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RSA加解密以及数字签名"><a href="#RSA加解密以及数字签名" class="headerlink" title="RSA加解密以及数字签名"></a>RSA加解密以及数字签名</h3><ul><li>加解密原理 ：公钥加密、私钥解密</li><li></li></ul><ul><li>数字签名原理：私钥签名（加密）；公钥验证（解密）</li><li></li><li></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  修改以下两个个宏定义为给出的RSA 2048密钥(密钥存储在keys文件夹中)的绝对路径(或不做修改使用默认的相对路径),</span></span><br><span class="line"><span class="comment">//  用于后续调用</span></span><br><span class="line"><span class="comment">//      PUBLICKEY 为 rsa公钥的存储路径</span></span><br><span class="line"><span class="comment">//      PRIVATEKEY 为rsa私钥的存储路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLICKEY <span class="string">&quot;../keys/public.pem&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIVATEKEY <span class="string">&quot;../keys/private.pem&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//RSA 私钥、公钥用 RSA*指针表示</span></span><br><span class="line">RSA* rsa_private_key = <span class="literal">NULL</span>; <span class="comment">// 需要读取的rsa私钥，</span></span><br><span class="line">RSA* rsa_public_key = <span class="literal">NULL</span>; <span class="comment">// 需要读取的rsa公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数用于读取rsa密钥(公钥和私钥)</span></span><br><span class="line"><span class="comment">//  返回值:</span></span><br><span class="line"><span class="comment">//      true 代表读取成功</span></span><br><span class="line"><span class="comment">//      false 代表读取失败</span></span><br><span class="line"><span class="comment">// 其他说明:</span></span><br><span class="line"><span class="comment">// //      通过宏定义的路径和口令将rsa的公钥,私钥分别读取到rsa_private_key和rsa_public_key中s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">load_RSA_keys</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *p=<span class="literal">NULL</span>,*s=<span class="literal">NULL</span>;<span class="comment">//文件指针，FILE大写</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* rsa_public_path=PUBLICKEY;<span class="comment">//fopen第一个参数是const char*类型，所以需要转换</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* rsa_private_path=PRIVATEKEY;</span><br><span class="line">    p=<span class="built_in">fopen</span>(rsa_public_path,<span class="string">&quot;r&quot;</span>);<span class="comment">//&quot;r&quot; 字符串格式 而不是 &#x27;r&#x27;</span></span><br><span class="line">    s=<span class="built_in">fopen</span>(rsa_private_path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span> &amp;&amp; s!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PEM_read_RSA_PUBKEY</span>(p,&amp;rsa_public_key,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//PEM_read_RSA_PUBKEY读取 -----BEGIN PUBLIC KEY-----格式</span></span><br><span class="line">        <span class="comment">//PEM_read_RSAPublicKey读取-----BEGIN RSA PUBLIC  KEY-----格式</span></span><br><span class="line">        <span class="comment">// PEM_read_PUBKEY还需要其他格式转换一般不用</span></span><br><span class="line">        <span class="built_in">PEM_read_RSAPrivateKey</span>(s,&amp;rsa_private_key,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//私钥读取函数固定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(p);<span class="comment">//好习惯关闭文件指针</span></span><br><span class="line">    <span class="built_in">fclose</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">RSA_Encryption</span><span class="params">(string plaintext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">load_RSA_keys</span>();</span><br><span class="line">    <span class="type">int</span> flen=plaintext.<span class="built_in">length</span>(),elen;<span class="comment">//flen表示消息长度，elen表示一会加密完的密文长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * plaintext_cstr=plaintext.<span class="built_in">c_str</span>();<span class="comment">//首先将plaintext转换成const char * 再转换成const unsigned char *</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  res[<span class="number">1000</span>];<span class="comment">//用于存放密文的数组</span></span><br><span class="line">    elen=<span class="built_in">RSA_public_encrypt</span>(flen,<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(plaintext_cstr),res,rsa_public_key,RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="comment">//reinterpret_cast 强制转换  RSA_PKCS1_PADDING 填重都用这个格式</span></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt; <span class="type">char</span>*&gt;(res),elen)</span></span>;<span class="comment">//最后将数组中的密文输出，需要将res变为char类型，迭代的第二个参数是密文的长度</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数用于进行rsa私钥解密</span></span><br><span class="line"><span class="comment">//  参数:</span></span><br><span class="line"><span class="comment">//      ciphertext 代表输入的密文字符串</span></span><br><span class="line"><span class="comment">//  返回值:</span></span><br><span class="line"><span class="comment">//      string类型, 返回解密的结果</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">RSA_Decryption</span><span class="params">(string ciphertext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">load_RSA_keys</span>();</span><br><span class="line">    <span class="type">int</span> flen=ciphertext.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> mlen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ciphertext_cstr=ciphertext.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> res[<span class="number">1000</span>];</span><br><span class="line">    mlen= <span class="built_in">RSA_private_decrypt</span>(flen,<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(ciphertext_cstr),res,rsa_private_key,RSA_PKCS1_PADDING);<span class="comment">//注意函数名的变化</span></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(res),mlen)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数用于进行rsa签名生成</span></span><br><span class="line"><span class="comment">//  参数:</span></span><br><span class="line"><span class="comment">//      input 代表输入的明文字符串</span></span><br><span class="line"><span class="comment">//  返回值:</span></span><br><span class="line"><span class="comment">//      string类型, 返回解密签名结果后的明文</span></span><br><span class="line"><span class="function">string <span class="title">RSA_signature_signing</span><span class="params">(string input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">load_RSA_keys</span>();</span><br><span class="line">    <span class="type">int</span> flen=input.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> elen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input_cstr=input.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> res[<span class="number">1000</span>];</span><br><span class="line">    elen=<span class="built_in">RSA_private_encrypt</span>(flen,<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(input_cstr),res,rsa_private_key,RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="comment">//唯一的不同就是函数变了</span></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(res),elen)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数用于进行rsa签名验证</span></span><br><span class="line"><span class="comment">//  参数:</span></span><br><span class="line"><span class="comment">//      message 代表输入的签名结果</span></span><br><span class="line"><span class="comment">//      signature 代表签名的结果</span></span><br><span class="line"><span class="comment">//  返回值:</span></span><br><span class="line"><span class="comment">//      bool类型, 返回签名的结果, 验证成功为返回true, 失败返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RSA_signature_verify</span><span class="params">(string message, string signature)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">load_RSA_keys</span>();</span><br><span class="line">    <span class="type">int</span> flen=signature.<span class="built_in">length</span>(),elen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * signature_cstr=signature.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  res[<span class="number">1000</span>];</span><br><span class="line">    elen=<span class="built_in">RSA_public_dncrypt</span>(flen,<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(signature_cstr),res,rsa_public_key,RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt; <span class="type">char</span>*&gt;(res),elen)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str==message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc rsa_test.cpp -o try -lstdc++ -lcrypto//编译</span><br><span class="line"></span><br><span class="line">// 生成RSA私钥，存入PEM文件</span><br><span class="line">$ openssl genrsa -out rsa_pri.pem 2048</span><br><span class="line">// 从RSA私钥中提取公钥，存入PEM文件</span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> rsa_pri.pem -pubout -out rsa_pub.pem</span><br></pre></td></tr></table></figure><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><ul><li>流密码</li><li>算法分为两部分  构造和加密</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">rc4_encrypt</span><span class="params">(string data, string secret_key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="string">&quot;&quot;</span> || secret_key==<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//错误判定</span></span><br><span class="line">    RC4_KEY* key_m=<span class="keyword">new</span> RC4_KEY;<span class="comment">//RC4_KEY是个结构体，可以用指针+new，也可以直接声明（RC4_KEY key_m）,类型不可以用前者</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* secret_key_cstr=secret_key.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* data_cstr=data.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">RC4_set_key</span>( key_m, secret_key.<span class="built_in">length</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(secret_key_cstr));<span class="comment">//将输入的密钥转换成RC4格式，第一个算法</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> outdata[data.<span class="built_in">length</span>()<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">RC4</span>( key_m, data.<span class="built_in">length</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(data_cstr),outdata);</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(outdata),data.length())</span></span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此处实现你的代码</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">rc4_decrypt</span><span class="params">(string data, string secret_key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">rc4_encrypt</span>(data, secret_key);<span class="comment">//因为加解密都是异或，所以解密就是直接再一次加密</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>去看ppt</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请使用该函数将string类型转换为DES_cblock类型。（请勿更改此函数）</span></span><br><span class="line"><span class="comment">// - 该函数仅用于转换明文和密文内容，请不要把用此函数转换secret_key。</span></span><br><span class="line"><span class="comment">// - secret_key请使用`DES_string_to_key()`函数转换。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">convert_string_to_des_block</span><span class="params">(string str, DES_cblock &amp;output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        output[i] = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DES_cblock是一种数组类型，unsigned char[8]，转换就是逐个转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数实现DES-ECB加密算法功能</span></span><br><span class="line"><span class="comment">//  参数:</span></span><br><span class="line"><span class="comment">//      plain - 输入的明文字符串</span></span><br><span class="line"><span class="comment">//      secret_key - 密钥</span></span><br><span class="line"><span class="comment">//  返回值:</span></span><br><span class="line"><span class="comment">//      string类型, 返回加密的结果</span></span><br><span class="line"><span class="comment">//  其他说明:</span></span><br><span class="line"><span class="comment">//      - 请使用`convert_string_to_des_block()`函数将string类型转换为DES_cblock类型。</span></span><br><span class="line"><span class="comment">//        若自行转换，可能导致测试无法通过</span></span><br><span class="line"><span class="comment">//      - secret_key使用前请用`DES_string_to_key()`设置key；</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">des_encrypt</span><span class="params">(string plain, string secret_key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DES_cblock input,key_,output;<span class="comment">//声明一些基本参数</span></span><br><span class="line">    DES_key_schedule schedule;<span class="comment">//DES采用的key是序列，所以需要转换</span></span><br><span class="line">    <span class="built_in">convert_string_to_des_block</span>(plain,input);<span class="comment">//将输入的密文转换成DES类型</span></span><br><span class="line">    <span class="built_in">DES_string_to_key</span>(secret_key.<span class="built_in">c_str</span>(), &amp;key_);<span class="comment">//将输入的密钥转换成DES类型</span></span><br><span class="line">    <span class="built_in">DES_set_key_unchecked</span>(&amp;key_, &amp;schedule);<span class="comment">//将DES类型的密钥再次转换成序列</span></span><br><span class="line">    <span class="built_in">DES_ecb_encrypt</span>(&amp;input,&amp;output,&amp;schedule, DES_ENCRYPT);<span class="comment">//加解密的函数头一样，区别是最后一个参数，因为不是类型，所以需要加&amp;</span></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(output),plain.length())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数实现DES-ECB解密算法功能</span></span><br><span class="line"><span class="comment">//  参数:</span></span><br><span class="line"><span class="comment">//      cipher - 输入的密文字符串</span></span><br><span class="line"><span class="comment">//      secret_key - 密钥</span></span><br><span class="line"><span class="comment">//  返回值:</span></span><br><span class="line"><span class="comment">//      string类型, 返回解密的结果</span></span><br><span class="line"><span class="comment">//  其他说明:</span></span><br><span class="line"><span class="comment">//      - 请使用`convert_string_to_des_block()`函数将string类型转换为DES_cblock类型。</span></span><br><span class="line"><span class="comment">//        若自行转换，可能导致测试无法通过</span></span><br><span class="line"><span class="comment">//      - secret_key使用前请用`DES_string_to_key()`设置key</span></span><br><span class="line"><span class="function">string <span class="title">des_decrypt</span><span class="params">(string cipher, string secret_key)</span> </span>&#123;</span><br><span class="line">    DES_cblock input,key_,output;</span><br><span class="line">    DES_key_schedule schedule;</span><br><span class="line">    <span class="built_in">convert_string_to_des_block</span>(cipher,input);</span><br><span class="line">    <span class="built_in">DES_string_to_key</span>(secret_key.<span class="built_in">c_str</span>(), &amp;key_);</span><br><span class="line">    <span class="built_in">DES_set_key_unchecked</span>(&amp;key_, &amp;schedule);</span><br><span class="line">    <span class="built_in">DES_ecb_encrypt</span>(&amp;input,&amp;output,&amp;schedule, DES_DECRYPT);</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(output),cipher.length())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">sha1_digest</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以用SHA1直接对短密文加密，以下是短、长密文都适用的</span></span><br><span class="line">    SHA_CTX ctx;<span class="comment">//声明类型</span></span><br><span class="line">    <span class="built_in">SHA1_Init</span>(&amp;ctx);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">SHA1_Update</span>(&amp;ctx, msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>());<span class="comment">//意思是将每块消息都进行更行映射，信息存储在ctx中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hash[SHA_DIGEST_LENGTH];  <span class="comment">// SHA_DIGEST_LENGTH is 20 for SHA-1</span></span><br><span class="line">    <span class="built_in">SHA1_Final</span>(hash, &amp;ctx);<span class="comment">//将ctx中的信息存入到结果数组中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将二进制哈希值直接作为std::string返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(hash), SHA_DIGEST_LENGTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="密码学基础知识回顾"><a href="#密码学基础知识回顾" class="headerlink" title="密码学基础知识回顾"></a>密码学基础知识回顾</h2><p>密码的四个性质：保密性、完整性、认证性、不可否认性</p><ul><li>唯密文攻击：只知道密文</li><li>已知明文攻击：一些明文和对应的密文</li><li>选择明文攻击：可以选择一些明文，并且得到相应的密文</li><li>选择密文攻击：选择密文得到相应的明文</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统与数据恢复</title>
      <link href="/2025/01/24/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
      <url>/2025/01/24/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">数据恢复技术：</span><br><span class="line">WinHex 中，Find Text搜索功能的使用</span><br><span class="line">备份和容灾系统概念</span><br><span class="line">回收箱原理，$I $R, 恢复清空回收箱后的数据恢复原理，分析十六进制数据</span><br><span class="line">RAID5常识</span><br><span class="line">分配策略的概念</span><br><span class="line">常见数据恢复工具</span><br><span class="line">RPO，RTO的概念</span><br><span class="line">存储设备破坏的原因</span><br><span class="line">机械硬盘修复顺序</span><br><span class="line">文件修复、文件系统修复的概念</span><br><span class="line">分区</span><br><span class="line">识别MBR和结构</span><br><span class="line">MBR代码（了解）</span><br><span class="line">分区大小，激活标志，EBR标志</span><br><span class="line">GPT头</span><br><span class="line">FAT</span><br><span class="line">文件删除/建立的过程（Del键删除、Shift+Del键删除）</span><br><span class="line">修复DBR的方法</span><br><span class="line">FAT32文件恢复中首簇号丢失的解决方法；</span><br><span class="line">长文件和短文件</span><br><span class="line">短文件名规范</span><br><span class="line">FDT结构：2E、 E5、 长文件名结构、首簇号、文件大小</span><br><span class="line"></span><br><span class="line">NTFS</span><br><span class="line">文件记录项基本结构，大小、起始标记、结束标记</span><br><span class="line">短文件名记录方式</span><br><span class="line">删除和创建过程</span><br><span class="line">WinHex：常见关键标志的搜索</span><br><span class="line"> 10H 30H 80H 90H A0H B0H的功能</span><br><span class="line">长文件和短文件</span><br><span class="line">ADS特点和存储方式</span><br><span class="line">30H 80H的结构</span><br><span class="line">时间特征保存位置</span><br><span class="line">取证中，访问时间判断和特征</span><br><span class="line">NTFS支持的功能</span><br><span class="line">DBR恢复过程，寻找DBR</span><br><span class="line">根据$MFT中$MFTMirr的内容，计算每簇的扇区数</span><br><span class="line">文件分配的大小，VCN概念</span><br><span class="line">找到并计算datarun，计算多运行的值，计算LCN</span><br><span class="line">NTFS EFS机制</span><br><span class="line">JPEG</span><br><span class="line">常见恢复点</span><br><span class="line">课件中的恢复案例</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="系统与数据恢复"><a href="#系统与数据恢复" class="headerlink" title="系统与数据恢复"></a>系统与数据恢复</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>一些定义</strong></p><ol><li>数据备份：从已有的备份中恢复数据的过程</li><li>数据恢复：从损坏的计算机、备份、文件或被删除的文件中恢复游泳数据的过程</li><li>计算机取证：运用计算机及其相关科学和技术的原理获取计算机相关的证据。以证明某个客观事实的过程</li></ol><p><strong>安全机制</strong></p><ol><li>用户鉴别<ul><li>用户标识—用户识别–用户验证–用户确认</li></ul></li><li>访问控制<ul><li>权限标记–授权组合–权限检查–违规处理</li></ul></li><li>安全保密<ul><li>信息隐藏–信息加密–信息锁定–信息控制</li></ul></li><li>安全审计<ul><li>访问记录–环境记录–审计追踪–审计确认</li></ul></li><li>安全恢复<ul><li>数据恢复–环境恢复–数据库恢复</li></ul></li></ol><p><strong>电子数据资源的脆弱性</strong></p><ol><li>电子数据可以伪造、访问、修改、删除</li><li>数据可泄露、复制、传输，动态可变易丢失</li><li>编程语言和工具可以访问磁盘，可以直接存取数据库</li></ol><p><strong>数据可恢复前提</strong></p><ol><li>备份有效及时</li><li>OS角度只是逻辑丢失</li><li>数据被取代不可逆，数据变化如文件删除可逆</li><li>只有低格和扇区覆盖才能彻底破坏数据</li></ol><p><strong>容灾和备份</strong></p><ul><li><p>数据备份：数据复制到其它存储介质的过程。侧重于数据的安全。</p><ol><li><p>备份：文件级备份、块级备份</p></li><li><p>复制：同步复制、异步复制</p></li><li><p>快照：基于文件系统的快照、卷快照</p></li><li><p>备份</p><ul><li><p>完全备份：在初始时间进行所有数据备份</p></li><li><p>差异备份：对完全备份开始变化的数据进行备份—多个时间点选择数据恢复，丢失数据可能性小</p></li><li><p>增量备份：只备份与上次备份有差异的部分—备份速度快，<strong>BUT</strong>必须有上次完全备份和需要增量备份的磁带，按顺序逐个恢复</p></li></ul></li></ol></li><li><p>容灾：异地构建相同的信息系统，实现业务切换。侧重于业务的安全。</p><ol><li>RPO（Recovery Point Object）：数据恢复完整性指标</li><li>RTO（Recovery Time Object）：业务恢复及时性指标</li></ol></li></ul><p><strong>文件损坏</strong></p><ul><li>存储部件和介质 的损坏</li><li>文件记录格式的损坏</li><li>文件搜索路径和关联结构的损坏</li><li>所记录的数据和文档的损坏丢失</li></ul><p><strong>数据恢复</strong></p><ol><li><p>软件恢复</p><ul><li>系统级恢复：修复软件修复系统</li><li>文件级恢复</li></ul></li><li><p>硬件恢复</p><ul><li>硬件替代</li><li>固件修复：修复工具修复</li><li>盘片读取</li></ul><p><strong>技术层次</strong></p><ol><li>软件恢复与简单的硬件替代</li></ol><p> 2.专业数据恢复工具</p></li></ol><p>​3.软硬件结合：专门设备</p><p>​4.磁信号</p><p><strong>降低故障</strong></p><ol><li>定期整理碎片</li><li>不要撞击硬盘</li><li>控制环境温度</li><li>硬盘原理磁场</li><li>杀毒 硬盘声音</li><li>数据不要放在系统盘 </li><li><strong>备份</strong></li></ol><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li><p>ST-506&#x2F;416：希捷开发，传输速率低，容量小，MFM</p></li><li><p>ESDI：迈拓开发，<strong>编、解码放在硬盘上，而不是控制卡上</strong></p></li><li><p>IDE(Integrated Drive Electronics)   <strong>ATA</strong>    和 EIDE</p><ul><li>将盘体和控制器<strong>集成</strong>在一起、</li><li>减少硬盘接口和电缆数目与长度</li><li>增强了数据传输的可靠性</li><li>提高了兼容性</li></ul></li><li><p>SATA：串行ATA，速率较高使用ATA指令集，热插拔 ，<strong>信号电压低</strong></p></li><li><p>M.2接口</p></li><li><p>SCSI：总线型的系统接口</p></li><li><p>USB：通用串行总线，需要主机硬件、操作系统和外设三个方面的支持才能工作。</p></li></ol><p><strong>传输模式</strong></p><ol><li>PIO模式(Programming Input&#x2F;Output Model)：一种通过CPU执行I&#x2F;O端口指令进行数据读写的数据交换模式</li><li>DMA模式（Direct Memory Access）：CPU通过DMA控制器直接访问内存</li><li>Ultea DMA模式（Direct Memory Access）：加入循环冗余码校验，双倍数据传输技术</li></ol><p><strong>传输策略</strong></p><ol><li>就近</li><li>FCFS</li><li>SSTF（寻找最近的）</li><li>SCAN（从最内侧到最外测）</li><li>CSCAN（到达最外侧后立刻返回）</li><li>LOOK（与SCAN相比，不必到达两侧）</li><li>CLOOK（与CSCAN相比，不必到达两侧）</li></ol><p><em><strong>传输参数</strong></em>*</p><ol><li>IOPS：每秒进行多少次IO<ul><li>取决于写入数据大小，非固定</li><li>频繁换道，写入数据块较大获得较低IOPS，<em>写入10000个大小1KB的文件比写一个10MB的文件耗时</em></li></ul></li><li>传输带宽<ul><li>高端产品同时具有较高的IOPS和带宽</li><li>&#x3D;数据&#x2F;时间</li></ul></li><li>磁盘缓存<ol><li>预读取：将正在读的下n个簇放到缓存中</li><li>写缓存：存入写入命令，返回已写入，等到磁盘空闲时再写入</li><li>存储频繁访问的数据</li></ol></li></ol><p><strong>运作流程</strong></p><ol><li>每个IO设备在启动时都要向内存中映射一个或者多个地址 </li><li>将IO地址放在北桥上，北桥等待CPU对该设备发出指令</li></ol><h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><ol><li>磁盘：硬盘、软盘</li><li>磁带</li><li>磁带：<strong>大容量</strong>数据存储，存储数据量大，不能作为数据实时存储介质</li><li>录音带</li></ol><p>方式：</p><ol><li>块式：数据被<strong>一块块</strong>的存放到介质上，可直接选择读写某一段数据，定位<strong>快</strong></li><li>流式：数据<strong>连续不断</strong>的存放到介质上，每个流之间可以<strong>有空隙</strong>用于定位，定位<strong>慢</strong></li></ol><p><strong>硬盘结构</strong></p><ul><li>接口<ul><li>电源接口</li><li>数据接口<ul><li>IDE</li><li>SCSI</li></ul></li></ul></li><li>控制电路板</li></ul><p><strong>读写原理</strong></p><ul><li>通关控制电路用硬盘读写头改变磁盘表面粒子簇N、S极性实现读写</li><li><strong>磁头不接触盘片</strong></li></ul><h3 id="CHS"><a href="#CHS" class="headerlink" title="CHS"></a>CHS</h3><ol><li><p>盘片</p><ul><li><strong>从0开始</strong></li><li>每个盘片有两个盘面</li><li>Aka<strong>磁头号</strong>，每个盘面对应一个磁头</li><li>电子切换</li></ul></li><li><p>磁道</p><ul><li><strong>从0开始</strong></li></ul></li><li><p>扇区</p><ul><li><p><strong>从1开始</strong></p></li><li><p><strong>组成</strong></p><p>- </p><ul><li><p>交叉因子</p><ul><li><p>比值表示法</p><p>17个扇区，按2：1的交叉因子编号</p><p>1、10、2、11、3、12、4、13、5、14、6、15、7、16、8、17、9</p><p>转完需要<strong>两圈</strong></p></li><li><p>太高：需要等待磁盘存入和读出</p></li><li><p>太低：降低性能</p></li></ul></li></ul></li></ul></li><li><p>柱面</p><ul><li><strong>从0开始</strong></li><li>所有盘面上的同一个磁道构成柱面</li><li>机械切换</li><li>同一柱面所有磁头读写完毕，才移动磁头到下一柱面</li></ul></li><li><p>格式</p><table><thead><tr><th>C</th><th>柱面</th><th>16位</th></tr></thead><tbody><tr><td>H</td><td>磁头</td><td>4位</td></tr><tr><td>S</td><td>扇面</td><td>8位</td></tr><tr><td>CS</td><td>起始柱面</td><td>0</td></tr><tr><td>HS</td><td>起始磁头</td><td>0</td></tr><tr><td>SS</td><td>起始扇区号</td><td>1</td></tr><tr><td>PS</td><td>每个磁道有多少扇区</td><td>63</td></tr><tr><td>PH</td><td>每个柱面有多少磁道</td><td>255</td></tr></tbody></table><p><strong>实际的CHS取决于min(ATA,INT 13)</strong></p></li></ol><hr><h3 id="LBA"><a href="#LBA" class="headerlink" title="LBA"></a>LBA</h3><p><a href="https://zhuanlan.zhihu.com/p/608292324">CHS和LBA的换算小记 - 知乎 (zhihu.com)</a></p><p><strong>LBA&#x3D;（C-CS）x PH x PS + (H-HS) x PS + (S-SS)</strong></p><ul><li>地址转换通过硬盘控制器完成</li><li>OS对磁盘的访问不需要调用INT 13h</li><li>需要BIOS做CHS到LBA的转换</li></ul><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><ol><li><p>硬盘容量&#x3D;盘<strong>面</strong>数x柱面数x扇区数x512字节</p><p>​              &#x3D;H * C * T * B</p></li></ol><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>参考：<a href="https://www.cnblogs.com/tham/p/6827151.html">操作系统启动过程——启动引导+硬件自检+系统引导+系统加载+系统登录 - _tham - 博客园 (cnblogs.com)</a></p><ol><li><p>BIOS:Basic Input Output System  <strong>软件程序和硬件设备之间的枢纽</strong></p><ul><li>系统BIOS</li><li>显卡BIOS</li><li>其他BIOS</li></ul></li><li><p><strong>位置</strong></p></li></ol><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><ul><li>BOOT Sector&#x3D;MBR（446）+DPT（64）+55AA（2）<ul><li>MBR&#x3D;引导程序（139）+错误信息数据区（79）+空（228）</li></ul></li></ul><h3 id="DPT"><a href="#DPT" class="headerlink" title="DPT"></a>DPT</h3><p>注意后面两个四字节参数的单位都是<strong>扇区</strong></p><p><strong>偏移4</strong>的标志</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><h4 id="低级格式化"><a href="#低级格式化" class="headerlink" title="低级格式化"></a><strong>低级格式化</strong></h4><ul><li>硬盘物理格式化</li><li>划分柱面和磁道，扇区，交叉因子</li><li>标识ID、数据区</li><li>测试磁盘表面，标志坏磁道和扇区</li><li>低格后OS不能使用，单纯的写数据可以进行</li></ul><h4 id="分区和卷"><a href="#分区和卷" class="headerlink" title="分区和卷"></a><strong>分区和卷</strong></h4><p>分区（Partition）和卷（Volume）是计算机存储管理中的两个重要概念，但它们在功能和用途上有所不同。</p><p><strong>分区（Partition）</strong></p><p><strong>定义：</strong><br>分区是指将一块物理硬盘划分成若干个独立的区域，每个区域称为一个分区。分区是在物理层面上的划分，是硬盘的逻辑分割单位。</p><p><strong>特点：</strong></p><ol><li><strong>物理划分</strong>：分区是对物理硬盘的直接划分，每个分区对应硬盘上的一个连续存储区域。</li><li><strong>启动信息</strong>：通常第一个分区包含主引导记录（MBR）或GUID分区表（GPT），用于引导操作系统。</li><li><strong>类型限制</strong>：一个硬盘上可以有若干个主分区和扩展分区（MBR模式下最多4个主分区或3个主分区加一个扩展分区，GPT模式下几乎没有限制）。</li><li><strong>文件系统</strong>：每个分区可以格式化成不同的文件系统，比如NTFS、FAT32、EXT4等。</li></ol><p><strong>卷（Volume）</strong></p><p><em>不连续，可跨区</em></p><p><strong>定义：</strong><br>卷是指在操作系统层面上，将一个或多个分区或物理磁盘合并成一个逻辑存储单元。卷可以跨越多个硬盘或多个分区，提供更灵活的存储管理。</p><p><strong>特点：</strong></p><ol><li><strong>逻辑划分</strong>：卷是对存储资源的逻辑管理单位，可以由一个或多个分区组成。</li><li><strong>灵活性</strong>：卷管理可以实现动态调整存储大小、增加或减少卷的容量。</li><li><strong>卷管理器</strong>：现代操作系统通过卷管理器（如Windows的动态磁盘管理、Linux的LVM）来管理卷，可以实现卷的创建、删除、扩展等操作。</li><li><strong>高级功能</strong>：卷可以实现镜像、条带化（RAID 0）、镜像（RAID 1）、纠错（RAID 5）等功能，增强数据可靠性和性能。</li></ol><p><strong>区别总结</strong></p><ol><li><p><strong>层次不同</strong>：</p><ul><li>分区是物理层面的划分。</li><li>卷是逻辑层面的划分。</li></ul></li><li><p><strong>用途不同</strong>：</p><ul><li>分区用于划分硬盘的物理区域，通常用于安装操作系统和引导计算机。</li><li>卷用于灵活管理存储资源，可以跨越多个分区和硬盘。</li></ul></li><li><p><strong>管理工具</strong>：</p><ul><li>分区管理使用工具如fdisk、parted、Disk Management（Windows）。</li><li>卷管理使用工具如LVM（Linux）、Disk Management（Windows的动态磁盘）。</li></ul></li></ol><p>通过理解分区和卷的区别，可以更好地管理计算机存储资源，提高存储系统的灵活性和效率。</p><h4 id="高级格式化"><a href="#高级格式化" class="headerlink" title="高级格式化"></a>高级格式化</h4>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛概</title>
      <link href="/2025/01/24/%E6%AF%9B%E6%A6%82/"/>
      <url>/2025/01/24/%E6%AF%9B%E6%A6%82/</url>
      
        <content type="html"><![CDATA[<h1 id="毛概"><a href="#毛概" class="headerlink" title="毛概"></a>毛概</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>群众路线 是 根本工作路线  ；实事求是是党的根本思想路线；独立自主是党的根本政治原则</li><li>毛的精髓是 实事求是，群众路线和独立自主是灵魂的基本方面</li><li>实事求是是马的基本观点，是党认识世界、改造世界的根本要求，是党的基本思想方法、工作方法、领导方法</li><li>十一六中全会 《中共关于建国以来党的若干历史问题的决议》对毛泽东科学评价</li><li>毛泽东思想就是对的</li><li>三座大山：封建、帝国、官僚资本主义</li><li>七大确立 实事求是的思想路线；十一届三中全会重新确立</li><li>解决中国一切革命问题最基本的依据是：认清中国国情</li><li>我国过去对什么是社会主义的问题没有完全搞清楚一个重要的原因是:没有科学的把握社会主义的发展规律</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol><li><p>新民主主义革命的根本目的是扫除阻碍中国生产力发展的落后的生产关系，解放发展生产力</p></li><li><p>无产阶级的领导权问题是中国革命的中心问题，也是新民主主义革命理论的核心问题；领导权在谁手里用于区分新旧民主主义革命</p></li><li><p>土地革命是民主革命的基本内容；武装斗争是主要形式，其他两个的保证；农村革命根据地建设战略阵地，其他俩个的依托</p></li><li><p>革命的根本原因：近代中国政治经济发展不平衡</p></li><li><p>革命的主力军是农民；坚强后盾：相当力量正式红军的存在</p></li><li><p>统一战线最根本的经验就是正确处理好与资产阶级的关系。</p></li><li><p>毛泽东指出:“领导的阶级和政党，要实现自己对于被领导的阶级、阶层、政党和人民团体的领导，必须具备两个条件:(甲）率领被领导者(同盟者)向着共同敌人作坚决的斗争，并取得胜利;(乙）对被领导者给以物质福利，至少不损害其利益，同时对被领导者给以<strong>政治教育</strong>。没有这两个条件或两个条件缺一，就不能实现领导。”</p></li><li><p><img src="C:/Users/LEGION/AppData/Roaming/Typora/typora-user-images/image-20240622140923839.png" alt="image-20240622140923839"></p></li><li><p>民族资产阶级建国前两面性：革命&amp;动摇 软弱&amp;妥协</p><p>建国后：剥削&amp;接受工人阶级领导改造</p></li><li><p>三大优良作风。这个论述在现行的《中国共产党章程》中被进一步明确为理论联系实际、密切联系群众、批评和自我批评三大优良作风，这是中国共产党区别于其他政党的显著标志。</p></li><li><p><img src="C:/Users/LEGION/AppData/Roaming/Typora/typora-user-images/image-20240622141902740.png" alt="image-20240622141902740"></p></li><li><p>、城市小资产阶级不是剥削阶级，而是被剥削阶级。题干中的剥削阶级主要是指地主阶级和民族资产阶级。</p></li><li><p>建立统一战线的必要性：1、半半决定 2、中国革命的长期性、残酷性、不平衡</p></li><li><p>建立统一战线的可能性：1、各种复杂矛盾交织一起2、民族资产的两面性</p></li><li><p>革命首要问题：分清敌友；基本：农民；核心：无产阶级的领导权</p></li><li><p>近代中国半殖民地半封建的性质和中国革命的历史人物决定了是资产阶级革命</p></li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol><li>建国实现对 官僚资本主义消灭、向新民主主义社会的转变‘</li><li>建国土地改革后工人阶级和资产阶级的矛盾成为主要的</li><li>改造期间，社会主义经济领导而不是主体，个体是主体</li><li>土地改革的基本完成是在1952年年底，标志着封建地主阶级剥削的消除</li><li>农业改造原则：自愿互利、典型示范、国家帮助</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol><li>毛泽东认为:“社会主义这个阶段，又可能分为两个阶段，第一个阶段是不发达的社会主义，第二个阶段是比较发达的社会主义。后一阶段可能比前一阶段需要更长的时间。<br>社会主义初级阶段是由邓小平同志最先提出的，不可能出现在毛泽东的论断中。</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol><li><p>实事求是</p><ul><li>起源于 《反对本本主义》</li><li>《矛盾论》《实践论》哲学概括、系统阐述</li><li>延安整风全党共识</li><li>十一3重新确立</li></ul></li><li><p>社会主义初级阶段</p><ul><li>毛 不发达 比较发达</li><li>十一6首次提出</li><li>十三大前夕把他作为事关全局的国情加以把握</li><li>十三大首次对其理论做系统的整理</li></ul></li><li><p>社会主义制度不能改只能完善；体制可以根本变革</p></li><li><p>改革是直接动力；根本动力是2对基本矛盾</p></li><li><p>基本国策：对外开放、一国两制、节约资源、保护环境</p></li><li><p>世界核心问题：南北发展问题；宗旨：维护世界和平；纲领、根本途径：反对霸权主义、强权政治问题 </p></li><li><p>党的实事求是思想路线：</p><ul><li>前提和基础：一切从实际出发</li><li>实质和核心：实事求是</li><li>验证条件和目的：在实践中检验真理和发展真理</li></ul></li><li><p>十三大我们党第一次对中国特色社会主义理论进行系统的概括，标志着邓小平理论轮廓的形成</p></li><li><p>实事求是是解放思想的内在要求和目的；解放思想是实事求是的前提条件</p></li><li><p>社会主义的根本目的：实现共同富裕； 消除两级分化是目标之一；解放和发展生产力是根本任务；消灭剥削是社会主义制度的本质需求</p></li><li><p>发展是目的、硬道理；必要前提和最高利益是稳定；改革是动力、制度自我完善和发展</p></li><li><p>社会主义初级阶段基本经济制度：作为社会主义经济基础的公有制经济，也包括非公有制经济。<br>王扰选项<br>公有制经济具有社会主义性质，非公有制经济不属于社会主义经济<br>非公有制经济是社会主义市场经济的重要组成部分，而不是社会主义经济的重要组成部分。社会主义经济一般指集中程度较高的公有制经济，其重要组成部分包括国有经济和集体经济。<br>非公有制经济不是具有公有制性质的经济，国有经济和集体经济才具有公有制性质。</p></li><li><p>所有制是社会主义和资本主义的区别；生产关系的基础</p></li><li><p>与西方：生产资料所有制和发展目的不同</p></li><li><p>外交的前提只有 一个中国</p></li><li><p>资源配置的不同方式：市场 和 计划</p></li><li><p><img src="C:/Users/LEGION/Desktop/image-20240622220544282.png" alt="image-20240622220544282"></p></li><li><p>理论和实践证明，市场配置资源是最有效率的形式，市场决定资源配置是市场经济的一般规律、健全社会主义市场经济体制必须遵循这条规律，</p></li><li><p>新民主和社会主义改造是毛泽东思想形成的实践基础；中国革命建设改革是三次飞跃的基础;改革开放和现代化建设实践是邓小平理论的现实依据；社会主义建设的经验教训是邓小平理论历史根据；系统分析新时代标志我国发展新的历史方位是习特条件</p></li><li><p>科学技术是第一生产力:</p><ul><li><p>科学技术对经济发展起着第一位的变革作用。</p></li><li><p>科学技术在生产力诸要素中成为主要的推动力量。</p></li><li><p>科学技术使管理日益现代化。</p></li></ul></li><li><p>社会发展的决定性力量是生产力，社会形态更替的根本标志是生产关系的变革。</p></li><li><p>计划和市场都是经济手段。不是划分社会制度的标志，本身不具有制度属性可以和制度结合</p></li><li><p>社会主义市场经济的基本特征主要体现在所有制结构、分配制度、宏观调控三个方面。</p></li><li><p>按劳分配是社会主义的分配原则，是由社会主义公有制和社会生产力的发展水平决定的。第一，公有制是实行按劳分配的所有制基础。第二，生产力发展水平是实行按劳分配的物质基础。</p></li><li><p>三个有利于：即是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民的生活水平。</p></li><li><p><strong>公有制的主体</strong>地位主要体现在两个方面:一是公有资产在社会总资产中占优势;二是<strong>国有经济</strong>控制国民经济命脉，对经济发展起主导作用。这是就全国而言的，有的地方、有些产业可以有所差别。鉴于过去只重视扩大公有资产在数量上的优势，不注意质盘的提高,</p></li><li><p>三个代表”重要思想的核心观点是，“中国共产党必须始终代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益”。</p></li><li><p>科学发展观的第一要义是发展；以人为本是核心立场；统筹兼顾是根本方法；推动经济社会发展是基本要求</p></li><li><p>依法治国目的是实现社会主义民主的制度化</p></li><li><p>党作为执政党面临的最根本的课题就是能不能始终代表最广大人民的根本利益</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2025/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h4><p>1.CSMA&#x2F;CD工作过程简述？</p><p>2NAT过程？</p><p>3.分组交换和电路交换优缺点？</p><p>4.协议以及协议栈</p><p>5..为什么在因特网中用到了不同的 AS 间与 AS 内部协议？ 答：①策略——在多个 AS 之间，策略问题占主导地位。 很重要的是，来自指定 AS 的流量不 能通过另一个指定 AS。 同样，指定的 AS 可能希望控制它在其他多个 AS 之间携带的过境交 通。 在 AS 内部，所有的东西名义上都在相同的管理控制下，因此策略在选择 AS 中的路由方 面的作用要小得多。 ②规模——路由算法及其数据结构对处理大量网络的路由的能力是 AS 间 路由的一个关键问题。 在 AS 内部，可伸缩性不那么受关注。 首先，如果单个管理域变得太 大，则始终可以将其划分为两个 AS 并在两个新的 AS 之间执行 AS 间路由。 ③性能——由于 AS 间路由是以策略为导向的，因此所使用的路由的质量(例如性能)往往是次要的问题(即满足某 些策略标准的较长或更昂贵的路由很可能被接管到较短但不符合该标准的路由上)。 事实上， 我们看到，在 AS 之间，甚至没有与路线相关的成本概念(除了 AS 跳数)。然而，在单个 AS 中， 这种策略关注的重要性较低，允许路由更多地关注在路由上实现的性能水平。</p><h1 id="记住"><a href="#记住" class="headerlink" title="记住"></a>记住</h1><p>1.第一章公示</p><p>2.端口号</p><p>3.样本时间公式</p><p>4.两个算法比较</p><h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><ol><li><p>延迟组件包括处理延迟（提取首部）、传输延迟（L&#x2F;R 路由器的分组发送、封装成帧）、传播延迟（距离&#x2F;时间）、排队延迟。除了排队延迟是变量，其他的都是固定的。</p><p><strong>链路传输速率</strong>：是指主机或路由器向链路上发送数据的速度，也称为数据率或比特，单位是比特每秒，b&#x2F;s</p><p>所以当t&#x3D;传输时间的时候，分组的第一个比特刚好离开主机</p><p><strong>链路传播速率</strong>：是指电磁波在信道中传播的速度，单位是m&#x2F;s。该速率取决于链路的物理媒体（如光纤、铜线等，其速率范围为2<em>10^8m&#x2F;s 至3</em>10^8m&#x2F;s。</p></li><li><pre><code class="language-python">//MB/s和Mb/s是有区别的。其中大B代表Byte(字节)，小b代表bit(比特 或位)。1 MB = 8 * 1 Mb1 Byte = 8 * 1 bit1 Kb = 1024 bit1 KB = 1024 Byte 1 Mb = 1024 Kb1 MB = 1024 KB1 Byte = 8 bit1 MB = 8Mb1 Mb = 0.125 MB<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 流量强度=La/R（最大发送速率/最大传输速率），a为分组到达队列的平均速率（分组/s），L为每组的比特量，R为传输速率</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">4. 四个封装应用层报文；传输层段;网络层数据段;链路层帧;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">5. 路由器处理网络、链路、物理层（第1到3层）、链路层交换机处理链路层和网络层（第1到2层）、主机处理所有的五层。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​6：【重要】p个分组通过由N条速率均为R的链路组成的路径(N-1个路由器)，ptp时延为</span><br><span class="line">$$</span><br><span class="line">N∗(L/R)+(P−1)∗(L/R)=(N+P−1)∗(L/R)</span><br><span class="line">$$</span><br><span class="line">​7：分组交换计算使用概率是用二项分布</span><br><span class="line"></span><br><span class="line">​     8：最大吞吐量=min&#123;Rs,Rc,R/M&#125;</span><br><span class="line"></span><br><span class="line">​9.协议栈综述</span><br><span class="line"></span><br><span class="line">​（1）应用层</span><br><span class="line"></span><br><span class="line">​协议：HTTP\SMTP\FTP\DNS(运行在UDP上)</span><br><span class="line"></span><br><span class="line">​分布：端系统</span><br><span class="line"></span><br><span class="line">​信息：报文</span><br><span class="line"></span><br><span class="line">​  （2）运输层</span><br><span class="line"></span><br><span class="line">​协议：TCP\UDP</span><br><span class="line"></span><br><span class="line">​信息：报文段</span><br><span class="line"></span><br><span class="line">​（3）网络层</span><br><span class="line"></span><br><span class="line">​协议：IP</span><br><span class="line"></span><br><span class="line">​信息：数据报</span><br><span class="line"></span><br><span class="line">​(4)链路层</span><br><span class="line"></span><br><span class="line">​协议：</span><br><span class="line"></span><br><span class="line">​信息：帧</span><br><span class="line"></span><br><span class="line">10.</span><br><span class="line"></span><br><span class="line">-  p2p（与c\s一类）</span><br><span class="line"></span><br><span class="line">  ​点对点即Peer-To-Peer，通常简写为P2P。所谓网络中的点对点，其实可以看成是一种对等的网络模型。P2P其实是实现网络上不同计算机之间，不经过中继设备直接交换数据或服务的一种技术。P2P由于允许网络中任一台计算机可以直接连接到网络中其他计算机，并与之进行数据交换，这样既消除了中间环节，也使得网络上的沟通变得更容易、更直接。</span><br><span class="line"></span><br><span class="line">  - ppp</span><br><span class="line"></span><br><span class="line">    ​       PPP(Point-to-Point、链路层协议)是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作</span><br><span class="line"></span><br><span class="line">    ​tcp就是点对点的，所以是全双工的</span><br><span class="line"></span><br><span class="line">- ​    p2p优点：自扩展性强 占用带宽少 成本低 分发时间快</span><br><span class="line"></span><br><span class="line">11.</span><br><span class="line"></span><br><span class="line">- **电路交换（Circuit Switching**）：电路交换是一种建立专用通信路径的通信方式。在电路交换中，通信的源和目的地之间建立一个持续的、专用的物理连接，该连接在通信会话期间一直保持不变。在建立连接之后，通信路径上的资源（如带宽）被独占使用，无论是否有数据传输。典型的电路交换协议是电话网络中的传统电话通信。电路交换适合实时通信，对延迟和可靠性有较高要求，但资源利用率较低。</span><br><span class="line">- **分组交换（Packet Switching）**：分组交换是一种将数据划分为小的数据包，并以独立的方式进行传输的通信方式。在分组交换中，数据被划分为固定大小的数据包（称为分组或数据报），每个分组带有目标地址和其他控制信息。这些分组通过网络独立传输，可能采用不同的路径和中间节点进行路由和转发。分组交换的典型协议是Internet中的IP（Internet Protocol）。分组交换具有较高的资源利用率，能够在网络中共享带宽，但在传输过程中可能会有延迟、丢包和重新排序等现象。</span><br><span class="line"></span><br><span class="line">总体而言，电路交换适合于实时通信，对可靠性和延迟要求较高，但资源利用率较低。而分组交换适用于大规模数据通信，具有较高的资源利用率，但对延迟和可靠性要求相对较低。现代的计算机网络通常采用基于分组交换的协议，如IP网络，以满足大规模数据通信的需求。</span><br><span class="line"></span><br><span class="line">12.网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信</span><br><span class="line"></span><br><span class="line">13.常见端口号</span><br><span class="line"></span><br><span class="line">| 协议/服务名称 | 端口号 | 简介                                                         |</span><br><span class="line">| ------------- | ------ | ------------------------------------------------------------ |</span><br><span class="line">| ftp           | 21     | File Transfer Protocol 文件传输协议，20用于连接，21用于传输  |</span><br><span class="line">| ssh           | 22     | [Secure Shell](https://baike.baidu.com/item/Secure Shell) 安全外壳协议，专为[远程登录](https://baike.baidu.com/item/远程登录/1071998)会话和其他网络服务提供安全性的协议 |</span><br><span class="line">| http          | 80     | Hyper Text Transfer Protocol 超文本传输协议，用于网页浏览    |</span><br><span class="line">| DNS           | 53     | Domain Name System 域名系统，域名解析                        |</span><br><span class="line">| https         | 443    | Hypertext Transfer Protocol Secure 超文本传输安全协议，用于安全浏览网页 |</span><br><span class="line">| www代理服务   | 8080   | Apache Tomcat web server，进行网页浏览                       |</span><br><span class="line">| smtp          | 25     | Simple Mail Transfer Protocol 简单邮件传输协议               |</span><br><span class="line">| telnet        | 23     | 不安全的文本传送                                             |</span><br><span class="line">| pop3          | 110    | Post Office Protocol                                         |</span><br><span class="line"></span><br><span class="line">DHCP    67</span><br><span class="line"></span><br><span class="line">14.</span><br><span class="line"></span><br><span class="line">**网络边缘**：用户直接使用的主机组成，网络边缘是网络存在的理由。</span><br><span class="line"></span><br><span class="line">**网络核心**：为网络边缘部分提供服务，由大量的网络及连接这些网络的路由器组成。</span><br><span class="line"></span><br><span class="line">15. 主机的IP地址或者名字+目的端口号 才能唯一确定一个进程     bgp–tcp</span><br><span class="line"></span><br><span class="line">对等层p2p采用协议进行通信</span><br><span class="line"></span><br><span class="line">17.协议的基本要素：语法、语义、同步</span><br><span class="line"></span><br><span class="line">网络协议是：通信双方必须遵守的报文格式</span><br><span class="line"></span><br><span class="line"># 第二章 应用层</span><br><span class="line"></span><br><span class="line">#### cookie</span><br><span class="line"></span><br><span class="line">当用户第一次访问站点时，服务器将创建一个唯一的标识号，在其后端数据库中创建一个条目，并将此标识号作为cookie编号返回。此cookie编号存储在用户的主机上，并由浏览器管理。在每次后续访问（和购买）期间，浏览器将cookie编号发送回站点。因此，站点知道这个用户（更准确地说，是这个浏览器）访问该站点的时间。</span><br><span class="line"></span><br><span class="line">2：邮件术语：邮件服务器</span><br><span class="line"></span><br><span class="line">3: 套接字(API):应用层（进程）和运输层之间的接口，可以通过其控制应用层，但对运输层协议只能选择协议以及设置最大报文长度和缓存长度 </span><br><span class="line"></span><br><span class="line">4：请求与响应必定成对，非持续连接中每个TCP连接只传输一个请求报文和一个响应报文。</span><br><span class="line"></span><br><span class="line">5：HTTP持续连接一个TCP连接可传输一个web或者同一个服务器的多个web</span><br><span class="line"></span><br><span class="line">6：UDP for DNS；TCP for HTTP</span><br><span class="line"></span><br><span class="line">7：HTTP报文中的date：服务器查找并发送该响应报文的日期和时间</span><br><span class="line"></span><br><span class="line">8：HTTP不能使用SMTP使用的方法，因为HTTP消息可以是二进制数据，而在SMTP中，消息主体必须是7位的ASCII格式。</span><br><span class="line"></span><br><span class="line">#### **DNS（域名系统）**</span><br><span class="line"></span><br><span class="line">- 运行在UDP上，端口53</span><br><span class="line"></span><br><span class="line">- 作用：主机的DNS从URL中提取主机名，端DNS向服务器通过UDP查询主机名对应的IP，然后建立TCP（**解析域名**）</span><br><span class="line"></span><br><span class="line">- 分类：根DNS 顶级域DNS（TLD）权威DNS **本地DNS**</span><br><span class="line"></span><br><span class="line">- 查询：ISP给主机本地DNS ip地址，主机-&gt;本地DNS-根DNS-TLD DNS-权威DNS  主机只和本地交流（递归查询） 本地和其他三个交流（递归查询）也可以全是递归</span><br><span class="line"></span><br><span class="line">- 缓存：本地DNS可缓存一段时间</span><br><span class="line"></span><br><span class="line">- DNS资源记录</span><br><span class="line"></span><br><span class="line">  RR（Name,Value,Type,[TTL]）</span><br><span class="line"></span><br><span class="line">    （1）(主机名，IP，A)</span><br><span class="line"></span><br><span class="line">  ​ (2) （域，知道如何获得该域中主机IP地址的权威DNS服务器的主机名，NS）</span><br><span class="line"></span><br><span class="line">    （3）（主机，规范主机名，CNAME）</span><br><span class="line"></span><br><span class="line">    （4）（邮件服务器，规范主机名，MX）</span><br><span class="line"></span><br><span class="line">#### FTP</span><br><span class="line"></span><br><span class="line">- 运行在TCP上，20端口传输数据，21端口用于控制传输命令</span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **HTTP**</span><br><span class="line"></span><br><span class="line">- web的协议 超文本传输协议</span><br><span class="line">- url=主机名+具体对象的路径名</span><br><span class="line">- 运行在TCP之上  无状态协议（不保存信息）</span><br><span class="line">- 建议过程：客户发起TCP建立请求—–建立后通过TCP上的套接字访问TCP传输HTTP请求和接收HTTP响应报文（响应时间为 2RTT+传输HTML的时间）</span><br><span class="line">- 分类：非持续连接 </span><br><span class="line"></span><br><span class="line">  ​       持续连接（分为 带流水线【一次传10个都可以】和不带流水线）</span><br><span class="line">- 报文格式</span><br><span class="line"></span><br><span class="line">#### **电子邮件**</span><br><span class="line"></span><br><span class="line">- ​组成：用户代理 邮件服务器 SMTP</span><br><span class="line"></span><br><span class="line">- SMTP 握手</span><br><span class="line"></span><br><span class="line">  - [ ] ​简单邮件传输协议 运行在TCP之上</span><br><span class="line"></span><br><span class="line">  - [ ] 二进制多媒体—转换为7位ASCII码—还原到二进制多媒体数据</span><br><span class="line"></span><br><span class="line">  - [ ] 过程:A–提供目的邮件地址给用户代理—-用户代理发给A的邮件服务器—-向B的邮件服务器建立TCP传输报文—B接受放入B的用户代理——B阅读</span><br><span class="line"></span><br><span class="line">    ​特点：直达、不经过中间服务器  </span><br><span class="line"></span><br><span class="line">    ​没发送成功后（B的邮件服务器没开机）留在A的服务器而不是B，在A进行多次发送尝试或者一段时间后删除</span><br><span class="line"></span><br><span class="line">    ​持续连接</span><br><span class="line"></span><br><span class="line">    ​HTTP拉协议 SMTP推协议</span><br><span class="line"></span><br><span class="line">-   端邮件访问协议</span><br><span class="line">  - IMAP</span><br><span class="line">  - POP3</span><br><span class="line">  - HTTP</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第三章 运输层</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line"></span><br><span class="line">2.TCP是面向字节的</span><br><span class="line"></span><br><span class="line">3.udp校验和运算时，如果两个字节的同一个位置同时进行反转，那么结果是不会变的</span><br><span class="line"></span><br><span class="line">4.mss加包头数据就等于mtu. 简单说拿TCP包做例子。 报文传输1400字节的数据的话，那么mss就是1400，再加上20字节IP包头，20字节tcp包头，那么mtu就是1400+20+20. 当然传输的时候其他的协议还要加些包头在前面，总之mtu就是总的最后发出去的报文大小。mss就是你需要发出去的数据大小</span><br><span class="line"></span><br><span class="line">4.</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>TCP始终发送带有预期序列的ACK编号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 运输层知识体系梳理</span><br><span class="line"></span><br><span class="line">#### 综述</span><br><span class="line"></span><br><span class="line">- 对象 ：为不同主机上的应用进程提供逻辑通信</span><br><span class="line">- 实现：在端系统中实现，将报文移动到网络边缘（网络层）</span><br><span class="line">- 封装：运输岑报文段（传递给网络层后，网络层封装成数据包，网络层不检查已经在数据报中的运输层报文段）</span><br><span class="line">- 特点：受限于底层网络层的服务模型</span><br><span class="line">- 底线：最低限度提供一种复用分解服务</span><br><span class="line"></span><br><span class="line">#### 多路复用和多路分解</span><br><span class="line"></span><br><span class="line">- 过程：运输层–&gt;进程拥有的套接字–&gt;进程</span><br><span class="line">- 多路复用：源主机从不同**套接字**收集数据块并且封装首部信息（用于分解）生成报文段，传递给网络层</span><br><span class="line">- 多路分解：将运输层的报文段中的数据交付到正确的套接字的工作</span><br><span class="line">- 对报文段的要求：对套接字有唯一标识符、包含源和目的端口号字段（0-65535 0-1023为周知端口号）</span><br><span class="line">- UDP套接字（无连接）：二元组：目的IP和目的端口号（不同源ip的的相同目的IP和端口号将会传到一个地方去）</span><br><span class="line">- TCP套接字（有连接）：四元组：源IP 源端口号 目的IP 目的端口号</span><br><span class="line"></span><br><span class="line">#### UDP</span><br><span class="line"></span><br><span class="line">- 特点：时间控制更加精细 无连接建议 无连接状态 首部开销小</span><br><span class="line">- 用途：远程文件服务器、多媒体、因特网电话、网络管理、DNS域名解析</span><br><span class="line">- 报文结构：</span><br><span class="line"></span><br><span class="line">​（1）总共8字节的首部</span><br><span class="line"></span><br><span class="line">- 校验和差错检测</span><br><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line">#### 可靠数据传输协议  </span><br><span class="line"></span><br><span class="line">包括流水线技术和停等技术</span><br><span class="line"></span><br><span class="line">- ​</span><br><span class="line"></span><br><span class="line">#### 流水线可靠数据传输协议</span><br><span class="line"></span><br><span class="line">- 优点：停等协议利用率太低</span><br><span class="line"></span><br><span class="line">- 回退N步 GBN  接收方唯一维度的信息就是下一个预期要收到的分组序号</span><br><span class="line"></span><br><span class="line">- 窗口最大2^k-1</span><br><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line">  - ​选择重传 SR（selective repeat）</span><br><span class="line"></span><br><span class="line">    ​      序列号空间必须至少是窗口大小的两倍，k≥2w。</span><br><span class="line"></span><br><span class="line">    ​</span><br><span class="line"></span><br><span class="line">GBN 窗口&lt;=2^k^ -1 SR 窗口&lt;=2^k-1^</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**典型例题**</span><br><span class="line"></span><br><span class="line">发送分组1 2 3 4 5，假设第二个丢失，直到最后全收到 **TCP始终发送带有预期序列的ACK编号**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GBN浪费了大量的带宽，SR需要很大的数据链路层缓存空间</span><br><span class="line"></span><br><span class="line">运行在TCP上的协议：HTTP FTP SMTP</span><br><span class="line"></span><br><span class="line">运行在UDP上的协议：DNS DHCP</span><br><span class="line"></span><br><span class="line">#### TCP</span><br><span class="line"></span><br><span class="line">##### 特点：</span><br><span class="line"></span><br><span class="line">- 面向连接 全双工服务 点对点（1对1 不存在1VN）</span><br><span class="line"></span><br><span class="line">- 对比：• TCP具有GBN的特点 – 累积确认 – 一个重传定时器 • TCP具有SR的特点 – 只重传一个报文 – 缓存失序报文</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- MSS(最大报文长度) MTU（最大传输单元 链路层）Usually MTU为1460=1500(MTU)- 20(IP Header) -20 (TCP Header) TCP将大文件划分为长度为MSS的小块</span><br><span class="line"></span><br><span class="line">- TCP 的服务器程序必须先于其客户程序运行。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  因为运行在TCP之上的客户机/服务器应用程序在**客户机运行后**，**它会尝试向服务器进程发起连接，而此时如果服务器进程没有运行，客户机进程就可能认为服务器不可达，从而返回错误信息；**</span><br><span class="line"></span><br><span class="line">    对于UDP则没有这个要求，是因为运行在UDP之上的客户机/服务器应用程序在客户机进程运行之后不会向服务器进程发起连接，而是等待用户输入，因此客户程序可以先于服务器程序运行</span><br><span class="line"></span><br><span class="line">  - 报文（首部20字节）：</span><br><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line">  - 序号和确认号：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  - 确认号用于表达期望收到的下一个序号，累积确认 接收方总是返回期望的序号 • B先收到0-299，返回ACK=300 • 随后600-     899报文段，仍然返回ACK=300 </span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">​本题说明A可能是上一个ACK，也说明不一定所有的分组都是20 B即正常情况 41明显不可能</span><br><span class="line"></span><br><span class="line">​##### 往返时间估计和超时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 流量控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LastByteRcvd-LastByteRead&lt;&#x3D;RcvBuffer<br>Rwnd&#x3D;RcvBuffer-[LastByteRcvd-LastByteRead]<br>LastByteSent-LastByteAcked&lt;&#x3D;Rwnd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### TCP连接管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### TCP**拥塞控制**AIMD</span><br><span class="line"></span><br><span class="line">- 1.慢开始</span><br><span class="line">  2.拥塞控制</span><br><span class="line">  3.快恢复</span><br><span class="line"></span><br><span class="line">- **当\**cwnd&lt;ssthresh\**时，使用慢开始算法。**</span><br><span class="line"></span><br><span class="line">  **当\**cwnd&gt;ssthresh\**时，改用拥塞避免算法。**</span><br><span class="line"></span><br><span class="line">  **当\**cwnd=ssthresh\**时，慢开始与拥塞避免算法任意。**</span><br><span class="line"></span><br><span class="line">- ```text</span><br><span class="line">  - 超时：cwnd&amp;-&gt;1 ssthresh-&gt;cwnd/2（取下限）</span><br><span class="line">  </span><br><span class="line">  -  三个ACK：cwnd&amp;=（cwnd）/2+3   ssthresh-&gt;cwnd/2（取下限）</span><br></pre></td></tr></table></figure><ul><li><p>拥塞避免：线性增长，每秒一个MSS（y轴单位长度）</p></li><li><p>慢开始：指数级增长，2的指数</p></li><li><p>快速重传：收到三个冗余ACK后立刻发出这个ACK对应的分组</p></li><li><p>快速恢复：与上相同，主要在拥塞控制领域</p></li><li></li></ul><h1 id="第四章-网络层：数据平面"><a href="#第四章-网络层：数据平面" class="headerlink" title="第四章 网络层：数据平面"></a>第四章 网络层：数据平面</h1><p>1.数据平面的主要功能是转发数据包，转发数据报从它们的输入链路到它们的输出链路。例如，数据平面输入端口执行终止传入物理链路的物理层功能在路由器处，执行链路层功能以在另一个路由器上与链路层互操作传入链路的一侧，并在输入端口上执行查找功能。</p><p>控制平面的主要功能是路由，即确定数据包从源到目的地的路径。控制平面负责执行路由协议，响应连接的上下链路，与远程控制器通信，并执行管理功能。</p><p>2.输入端口、交换结构和输出端口在硬件中实现，因为它们的数据报处理功能对于软件实现来说太快了。传统路由器内部的路由处理器使用软件来执行路由协议，维护路由表和附加的链路状态信息，并计算路由器的转发表。此外，SDN路由器中的路由处理器还依赖于与远程控制器通信的软件，以便接收转发表条目并将它们安装在路由器的输入端口中。</p><p>数据平面通常由于需要快速而在硬件中实现例如以纳秒时标处理。控制平面通常在软件并以毫秒或秒时间工作,例如用于执行路由协议、响应向上或向下的附加链路,与远程控制器通信，并执行管理功能。</p><ol start="3"><li></li></ol><p>4.IPv6不进行分片操作，而是要求源端根据路径MTU发现和链路层的MTU进行适当的分段。(所以题目中分片的都是ipv4，首部字节为20)</p><h3 id="网络层：数据平面知识梳理"><a href="#网络层：数据平面知识梳理" class="headerlink" title="网络层：数据平面知识梳理"></a>网络层：数据平面知识梳理</h3><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><ul><li>数据平面：从输入链路接口向输出链路输出数据包 控制平面：协调这些本地路由器的转发动作（SDN）</li><li>转发是在数据平面实现的唯一功能，硬件实现</li><li>每台路由器中关键元素是它的转发表</li><li>服务模型 （因特网）：尽力而为模型</li></ul><h4 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h4><ul><li><p>​结构</p><p>​            输入端口:接收分组，查找路由表 </p><p>​            交换结构：将路由器的输入端口与输出端口相连</p><p>​            输出端口：存储输入端口交换而来的分组，传输 到链路上</p><p>​            路由选择处理器：路由表生成和维护(传统路由 器) </p><p>​            输入端口、输出端口和交换阵列往往用硬件实现，控制平面软件实现</p><p>​            转发方式：基于目的转发 and 通用转发（不学）</p></li></ul><h4 id="输入端口处理和基于目的转发"><a href="#输入端口处理和基于目的转发" class="headerlink" title="输入端口处理和基于目的转发"></a>输入端口处理和基于目的转发</h4><ul><li><p>最长前缀匹配原则</p><p>​        前缀越长，网络就越小，定位越精确；前缀越短，网络就越大</p></li><li><p>交换结构</p></li></ul><p>  ​</p><ul><li>经内存交换：速度受内存带宽限制 (每个分组需要两次经过总线)所以速率&lt;处理速率&#x2F;2  <strong>一次一个分组</strong></li><li>经总线交换：总 线 竞 争 : 交 换 速 率 受 总 线 带 宽 限 制  <strong>一次一个分组</strong></li><li>经互联网络交换：可以多个分组同时发（不同的输入端口但通向同一个输出端口，就要等待）</li></ul><h4 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h4><ul><li>HOL(head of the line )阻塞：A和C都要向同一个输出端口发，如果A先发，C就要等待</li><li>缓存B&#x3D;RTT*c&#x2F;N^0.5^N为TCP流的数量 C链路容量</li></ul><h4 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h4><ul><li><h4 id="先进先出：FIFO-FCFS"><a href="#先进先出：FIFO-FCFS" class="headerlink" title="先进先出：FIFO FCFS"></a>先进先出：FIFO FCFS</h4></li><li><h4 id="优先队列：-低优先权发出的时候，高优先的分组不能打断"><a href="#优先队列：-低优先权发出的时候，高优先的分组不能打断" class="headerlink" title="优先队列： 低优先权发出的时候，高优先的分组不能打断"></a>优先队列： 低优先权发出的时候，高优先的分组不能打断</h4></li><li><h4 id="循环排队：1-2-1-2-1-2-保持工作排队：1没分组可发了，就发2"><a href="#循环排队：1-2-1-2-1-2-保持工作排队：1没分组可发了，就发2" class="headerlink" title="循环排队：1 2 1 2  1 2  保持工作排队：1没分组可发了，就发2"></a>循环排队：1 2 1 2  1 2  保持工作排队：1没分组可发了，就发2</h4></li><li><h4 id="加权公平排队（WFQ）：-保持工作排队"><a href="#加权公平排队（WFQ）：-保持工作排队" class="headerlink" title="加权公平排队（WFQ）： 保持工作排队"></a>加权公平排队（WFQ）： 保持工作排队</h4></li></ul><h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><ul><li><p>报文（20字节）</p></li><li><p>切片，在端系统而不是路由器中组装</p></li><li><p>偏移以8字节为单位</p></li><li></li></ul><h5 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h5><ul><li>接口：主机和物理链路之间的边界  路由器和任意一条链路之间的边界  路由器有多个接口 – 主机可以有多个接口</li><li>一个IP与一个接口相互关联</li></ul><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ul><li><p>CIDR 无类别域间路由选择 a.b.c.d&#x2F;x x部分为子网或者网络（前缀）32-x为主机</p></li><li><p>ABC类网络编址</p></li><li><p><strong>IP地址</strong>是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。</p></li><li><p>​IP地址&#x3D;网络地址+主机地址（注意ABC类的网络地址区段以及默认掩码）</p></li><li><p><img src="https://img-blog.csdn.net/20160712182446560" alt="网络地址的划分"></p></li><li><p>主机标识段host 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p></li><li><p>主机地址全1是广播，全0是网络</p></li><li><ul><li><h1 id="根据IP地址和子网掩码求-网络地址-和-广播地址"><a href="#根据IP地址和子网掩码求-网络地址-和-广播地址" class="headerlink" title="根据IP地址和子网掩码求 网络地址 和 广播地址"></a>根据IP地址和子网掩码求 网络地址 和 广播地址</h1><hr><ul><li><p>子网即网络</p></li><li><p>将IP地址和子网掩码换算为二进制，子网掩码连续全1的是网络地址所占区间，后面的是主机地址</p></li><li><p><strong>IP地址和子网掩码进行与运算，结果是网络地址</strong>（即主机号全0是网络地址）</p></li><li><p>将运算结果中的网络地址不变，<strong>主机地址变为1，结果就是广播地址</strong></p></li><li><p>地址范围就是含在本网段内的所有主机</p></li><li><p>主机的数量&#x3D;2^主机地址所占比特-2</p></li></ul><p>减2是因为主机不包括网络地址和广播地址。</p><p><strong>示例</strong><br>一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址</p><h2 id="根据子网掩码可以分割网络号-主机号"><a href="#根据子网掩码可以分割网络号-主机号" class="headerlink" title="根据子网掩码可以分割网络号+主机号"></a>根据子网掩码可以分割网络号+主机号</h2><hr><p><code>255.255.255.224</code> 转二进制：</p><blockquote><p>11111111 11111111 11111111 11100000</p></blockquote><p>网络号有27位，主机号有5位</p><p>网络地址就是：把IP地址转成二进制和子网掩码进行与运算</p><p>11001010 01110000 00001110 10001001</p><p>IP地址&amp;子网掩码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11001010 01110000 00001110 10001001</span><br><span class="line"></span><br><span class="line">11111111 11111111 11111111 11100000</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">11001010 01110000 00001110 10000000</span><br></pre></td></tr></table></figure><p>即：202.112.14.128</p><h2 id="计算广播地址"><a href="#计算广播地址" class="headerlink" title="计算广播地址"></a>计算广播地址</h2><hr><p>广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159</p><h2 id="主机数"><a href="#主机数" class="headerlink" title="主机数"></a>主机数</h2><hr><p>主机号有5位，那么这个地址中，就只能有个主机30-2</p><p>因为其中全0作为网络地址，全1作为广播地址</p><h1 id="根据每个网络的主机数量进行子网地址的规划和计算子网掩码"><a href="#根据每个网络的主机数量进行子网地址的规划和计算子网掩码" class="headerlink" title="根据每个网络的主机数量进行子网地址的规划和计算子网掩码"></a>根据每个网络的主机数量进行子网地址的规划和计算子网掩码</h1><hr><p>这也可按上述原则进行计算。</p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是<br>10＋1＋1＋1＝13<br>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。<br>因为13小于16（16等于2的4次方），所以主机位为4位。</p><p>而 256－16＝240 所以该子网掩码为255.255.255.240。</p><p>如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为：<br>14＋1＋1＋1＝17<br>17.大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224</p><h1 id="206-110-1-0-18-被划分成16个子网，每个子网掩码？"><a href="#206-110-1-0-18-被划分成16个子网，每个子网掩码？" class="headerlink" title="206.110.1.0 &#x2F;18 被划分成16个子网，每个子网掩码？"></a>206.110.1.0 &#x2F;18 被划分成16个子网，每个子网掩码？</h1><hr><p>（划分成16个子网，根据子网掩码&#x2F;18就表示有18个1，就要从的IP地址的主机位借4位来用作网络位！）</p><p>子网掩码是255.255.252.0</p><p>每个子网可以容纳的主机数是1024台。</p><p>下面我来给你详细解答：</p><p>206.110.1.0 &#x2F;18 由最后的那个&#x2F;18，我们可以知道这个IP已经规定了它的网络位是18位，它默认的子网掩码就是11111111.11111111.11 | 000000.00000000(其中1代表网络位,0代表主机位)</p><p>可以看出我们可以操作的位数就是后面的14个0，也就是说我们可以在地面划分出几位作为子网的网络位，进而来划分子网。要求是切分成16个子网，我们知道2的4次方刚好等于16，这就说明子网网络位的位数是4位，那14-4&#x3D;10就是子网的主机位。所以上面我写的那串二进制就可以变成：11111111.11111111.111111 | 00.00000000(其中1代表网络位,0代表主机位)</p></li></ul></li></ul><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><ul><li>动态主机配置协议，用于获取主机地址</li><li>即插即用 零配置</li><li>四次握手</li><li>CS协议</li><li>过程：发现（客户广播包含DHCP发现报文的IP数据报）提供（选哪个） 请求（选这个）ACK（ok）</li></ul><h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><h4 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h4><ul><li>动机：32-bit 地址空间即将用尽</li><li>– 固定长度的 40 字节首部</li><li>•分片&#x2F;重组：不允许分片 • 校验和: 全部去掉，减少每一跳的处理时间</li><li>IPv4 到 IPv6过渡：双栈 隧道</li><li></li></ul><h4 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h4><h1 id="第五章-网络层：控制平面"><a href="#第五章-网络层：控制平面" class="headerlink" title="第五章 网络层：控制平面"></a>第五章 网络层：控制平面</h1><p>1.子网是较大网络的一部分；子网不包含路由器；其边界由路由器和主机接口定义。前缀是CDIR地址的网络部分；它以a.b.c.d&#x2F;x形式写成；前缀包括一个或多个子网。当路由器在BGP会话中通告前缀时，它在前缀中包含许多BGP属性。在BGP术语中，前缀及其属性是BGP路由(或简单地说是路由)。</p><p>2.列举 4 种不同的 ICMP 报文。 答：回显回答、目的网络不可达、目的主机不可达、目的端口不可达、源点抑制</p><p>3.由于在BGP、循环中从AS到目的地都提供了完整的路径信息检测是简单的-如果BGP对等体接收到包含自己的AS号的路由AS路径，然后使用该路由将导致环路</p><p>4.只要是路由器知道了自己 AS 以外的路由 情况就是通过 BGP 协议，只有自己 AS 内的路由情况才用 RIP 或 OSPF，在 AS 内部用 BGP 传 阅时使用 iBGP，在 AS 的各个发言人之间使用 BGP 传阅用 eBGP</p><p>5.OSPF基于IP，所以它是传输层协议；RIP基于UDP协议，BGP基于TCP协议，所以它们是应用层协议。”基于”即”运行于”</p><p>6.<strong>从动态路由协议的应用范围分</strong>：</p><ul><li>IGP-内部网关协议。（OSPF  RIP）</li><li>EGP-外部网关协议。(BGP)</li></ul><p><strong>从动态路由协议使用的算法分：</strong>：</p><ul><li>距离矢量路由算法:RIP</li><li>链路状态路由算法:OSPF</li></ul><p>7.BGP运行在自治系统之间，传递的是各子网可达的信息</p><h4 id="网络层：控制平面知识体系梳理"><a href="#网络层：控制平面知识体系梳理" class="headerlink" title="网络层：控制平面知识体系梳理"></a>网络层：控制平面知识体系梳理</h4><h5 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h5><h6 id="集中式路由选择算法：LS链路状态算法"><a href="#集中式路由选择算法：LS链路状态算法" class="headerlink" title="集中式路由选择算法：LS链路状态算法"></a>集中式路由选择算法：LS链路状态算法</h6><p>格式：维护N –D( * ) –P( * )[关键上一个节点]</p><p>搜索节点总数：n*(n+1)&#x2F;2    时间复杂度 O(n^2^)</p><h6 id="分散式路由选择算法：DV距离向量算法"><a href="#分散式路由选择算法：DV距离向量算法" class="headerlink" title="分散式路由选择算法：DV距离向量算法"></a>分散式路由选择算法：DV距离向量算法</h6><h5 id="IGP（AS【自治系统】）"><a href="#IGP（AS【自治系统】）" class="headerlink" title="IGP（AS【自治系统】）"></a>IGP（AS【自治系统】）</h5><h6 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h6><ul><li>DV算法核心</li><li></li><li></li><li>通告通过 UDP 报文(端口520)进行发送, 周期性重 复</li></ul><h6 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h6><h5 id="BGP（AS间）"><a href="#BGP（AS间）" class="headerlink" title="BGP（AS间）"></a>BGP（AS间）</h5><ul><li><p>分布式 异步</p></li><li><p>TCP 179端口号</p></li><li></li><li><p>​热土豆算法（贪心）：选择内部开销最小的送出去</p></li><li></li><li></li></ul><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><h1 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h1><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>1.适配器和交换机之间的关系是，适配器是计算机或设备与局域网之间的物理接口，它通过连接到交换机的端口来实现与其他设备的通信</p><p>2.链路层协议能够向网络层提供哪些服务？在这些链路层服务中，哪些在 IP中有对应的服务？ 哪些在 TCP 中有对应的服务？ 答：封装成帧：IP 和 TCP 中也有封装 MTU 的功能；链路接入；可靠交付：TCP 中也有可靠交 付；流量控制：TCP 中也有流量控制；差错检测：IP 和 TCP 中也有差错检测；纠错；全双工： TCP 也是全双工。【答案一共写了七种功能，P287 只写了五种，流量控制和全双工通信没写， 其中 TCP 可以实现 4 种，IP 可以实现 2 种】</p><p>3.答：时隙 ALOHA：1, 2 和 4(时隙 ALOHA 仅部分分散，因为它需要所有节点中的时钟同步)。 令牌环网：1, 2, 3, 4。【P294 具体写了四条特性，这里简单概述：1.当仅有一个节点发送数据时， 该结点具有全部吞吐量；2.当有多个节点发送数据时，各节点均分吞吐量；3.协议是分散的，不 会因为某主节点故障而导致系统崩溃；4.协议是简单的，能够轻易实现】</p><p>4.248个MAC地址；232232个IPv4地址；21282128个IPv6地址。</p><h4 id="链路层和局域网知识梳理"><a href="#链路层和局域网知识梳理" class="headerlink" title="链路层和局域网知识梳理"></a>链路层和局域网知识梳理</h4><ol><li>分类：点对点链路和广播信道</li></ol><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><ul><li>网络适配器（网络接口卡）&#x3D;控制器（核心）+物理传输</li><li>大部分在硬件，小部分在CPU实现【高层链路功能】</li></ul><h5 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h5><h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><ul><li>一维 二位</li><li>接收方检测和纠正错误 的能力：前向纠错FEC</li></ul><h5 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h5><h5 id="CRC（循环冗余检测）"><a href="#CRC（循环冗余检测）" class="headerlink" title="CRC（循环冗余检测）"></a>CRC（循环冗余检测）</h5><ul><li><p>d位bit数据D 余数R</p></li><li><p>**多项式模2运行：**实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1，也是不考虑进位、借位的二进制加减运算。如：10011011 + 11001010 &#x3D; 01010001。</p></li><li><p><strong>G生成多项式</strong>：最高位为1；r+1位bit</p></li><li><p>冗余添加：计算时将D后面添加r位0</p></li><li><p>例：</p><p>现假设选择的CRC生成多项式为G（X） &#x3D; X4 + X3 + 1，要求出二进制序列10110011的CRC校验码？</p><p>（1）G&#x3D; 首先把生成多项式转换成二进制数，由G（X） &#x3D; X4 + X3 + 1可以知道（，它一共是5位（总位数等于最高位的幂次加1，即4+1&#x3D;5），然后根据多项式各项的含义（多项式只列出二进制值为1的位，也就是这个二进制的第4位、第3位、第0位的二进制均为1，其它位均为0）很快就可得到它的二进制比特串为11001。 【有时候G会直接给出】</p><p>（2）       因为生成多项式的位数为5，根据前面的介绍，得知CRC校验码的位数为4（校验码的位数比生成多项式的位数少1）。因为原数据帧10110011，在它后面再加4个0，得到101100110000，然后把这个数以“模2除法”方式除以生成多项式，得到的余数（即CRC码）为0100，如下所示。</p><p><img src="https://img-blog.csdn.net/20170514161759680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2F5aGVsbG9fd29ybGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>（3）       把上步计算得到的CRC校验0100（R）替换原始帧101100110000后面的四个“0”，得到新帧101100110100。再把这个新帧发送到接收端。</p><p>（4）       当以上新帧到达接收端后，接收端会把这个新帧再用上面选定的除数11001以“模2除法”方式去除，验证余数是否为0，如果为0，则证明该帧数据在传输过程中没有出现差错，否则出现了差错</p><p>R&#x3D;remainder (D*2^r^&#x2F;G)</p></li></ul><h4 id="多路访问链路协议（MAC-multiple-access-control-protocol）"><a href="#多路访问链路协议（MAC-multiple-access-control-protocol）" class="headerlink" title="多路访问链路协议（MAC multiple access control protocol）"></a>多路访问链路协议（MAC <strong>multiple access control protocol</strong>）</h4><ul><li>点对点链路协议：PPP HDLC</li><li>广播(有线或无线共享) ：传统以太网   802.11无线局域网</li><li>DOCSIS</li></ul><h5 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h5><ul><li>TDM</li><li>FDM</li><li>CDMA 码分多址</li></ul><h5 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h5><h6 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h6><ul><li>P&#x3D;1&#x2F;N取得最大值</li></ul><h6 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h6><ul><li>p&#x3D;1&#x2F;(2N-1)</li></ul><h6 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA 载波侦听多路访问"></a>CSMA 载波侦听多路访问</h6><ul><li>由于信道传播时延还会引起冲突</li><li>载波侦听：有线网络容易实现，无线网络困难</li><li>CSMA&#x2F;CD用于以太网,CSMA&#x2F;CA用于无线网络</li></ul><h6 id="CSMA-CD-具有碰撞检测的载波侦听多路访问"><a href="#CSMA-CD-具有碰撞检测的载波侦听多路访问" class="headerlink" title="CSMA&#x2F;CD 具有碰撞检测的载波侦听多路访问"></a>CSMA&#x2F;CD 具有<strong>碰撞检测</strong>的载波侦听多路访问</h6><ul><li><p>于10 Mbps比特时间 为0.1微秒</p></li><li><p>拥塞信号：48比特，确保 所有传送者知道冲突发 生</p></li><li></li><li></li><li><p>总结：随机接入协议一个节点活跃具有R，但没实现多个节点活跃R&#x2F;M</p></li></ul><h5 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h5><h4 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h4><ul><li>交换机运行在链路岑，交换链路层帧，不交换网络层数据报</li></ul><h5 id="链路寻址和ARP"><a href="#链路寻址和ARP" class="headerlink" title="链路寻址和ARP"></a>链路寻址和ARP</h5><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul><li>并不是主机或者路由器具有链路层地址，而是适配器（网络接口）具有链路层地址</li><li>链路层交换机和主机路由器的接口不具有链路层地址，交换机是透明的</li><li>LAN地址、物理地址、MAC地址 Ethernet地址 多种叫法</li><li>长度六字节 十六进制表示法 固定</li><li>MAC地址相当于身份证 IP相当于收件地址</li><li>广播地址 &#x3D; FF-FF-FF-FF-FF-FF</li></ul><h5 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h5><h6 id="子网内部"><a href="#子网内部" class="headerlink" title="子网内部"></a>子网内部</h6><ul><li>广播帧出，标准帧回</li><li>知道目的MAC —- 直接查找ARP表</li><li>不知道目的MAC，将源目的IP以及源MAC包装成ARP分组，适配器广播帧作为目的MAC传到子网，目的主机返回响应ARP表，路由器更新ARP表</li><li>链路层和网络层协议的结合</li></ul><h6 id="子网外部"><a href="#子网外部" class="headerlink" title="子网外部"></a>子网外部</h6><ul><li>ARP—路由器左MAC—转发表—路由器右MAC——ARP</li></ul><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ul><li>星型拓扑结构</li><li>连接设备: 集线器hub或交换机switch</li></ul><h5 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h5><ul><li><p>前同步码，8个字节 p 前7个字节为 10101010，最后一个为 10101011</p></li><li><p>目的地址: MAC地址，6个字节 m 如果适配器收到的帧的目的地址与之匹配或者是一个广播地 址(ARP包)，就把帧传给网络层 m 否则，抛弃该帧</p></li><li></li><li><p>使用了CSMA&#x2F;CD</p></li><li><p>基于现代交换机的以太网是全双工、无碰撞的</p></li></ul><h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><ul><li>本质上是多口网桥</li><li>交换机表 自学习 来自哪个接口以及源MAC  即插即用</li><li>来自同一个子网的将被过滤</li><li>交换机具有大量接口 p 主机可以直接连接到交换机 p 没有冲突; 全双工模式运行</li><li>可混合各种共享&#x2F;专用, 10&#x2F;100&#x2F;1000 Mbps 接口</li><li>网桥和交换机可以划分冲突域，但是不能划分广播域</li></ul><p>即插即用：DHCP ARP 交换机表</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机安全原理与实践</title>
      <link href="/2025/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机安全原理与实践"><a href="#计算机安全原理与实践" class="headerlink" title="计算机安全原理与实践"></a>计算机安全原理与实践</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul><li>关键目标：机密性、完整性、可用性 CIA+ 真实性、可说明性</li><li>计算机中的资源：硬件、软件、数据、通信线路和网络</li><li>攻击形式：主动攻击、被动攻击、内部攻击、外部攻击</li></ul><h2 id="2-密码"><a href="#2-密码" class="headerlink" title="2.密码"></a>2.密码</h2><ul><li><p>攻击对称加密：密码分析、蛮力攻击</p></li><li><p>ECB（电子密码本、电话本）模式应用广泛：规律性、容易被破译</p></li><li></li><li><p>非对称加密：RSA、ECC（椭圆曲线密码加密）、Diffie-Hellman 密钥协议、数字签名标准(DSS)</p></li></ul><h2 id="3-用户认证"><a href="#3-用户认证" class="headerlink" title="3.用户认证"></a>3.用户认证</h2><p><strong>数字用户认证方法</strong></p><ul><li>四个认证方法：个人信息、物品（令牌）、生理特征（静态生物特征）、行为特征（动态生物特征）</li><li>三个风险评估独立概念：置信等级、潜在影响、风险范围</li></ul><p><strong>基于口令的认证</strong></p><ul><li><p>口令作用：<strong>口令系统是对于抵御入侵者应用最广泛的方法手段</strong></p></li><li><p>用户ID的三个作用</p><ul><li>决定了用户是否被授权访问系统</li><li>决定了该用户所拥有的的访问权限</li><li>应用在自主访问控制机制中</li></ul></li><li><p>四个口令破解方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以通过设置足够大的盐值以及设置较长的散列值来进行对抗</span><br></pre></td></tr></table></figure><ul><li>字典攻击</li><li>彩虹表攻击</li><li>猜测较短、带有用户喜好的口令</li><li>开源口令破解器</li></ul></li><li><p>应对措施</p><ul><li>口令文件访问控制</li><li>使用入侵检测技术对不安全行为识别</li><li>重新设置不安全口令</li><li>口令的限制balabla</li></ul></li><li><p>四种口令选择策略</p><ul><li>用户教育</li><li>计算机生成口令</li><li>后验口令检查：系统周期性地运行自己的口令破解程序来找到容易被猜测到的口令</li><li>先验口令检查：选择密码的时候计算机进行检查—口令检查器、Bloom 过滤器</li></ul></li><li><p>Salt目的</p><ul><li>防止复制的口令在口令文件中可见</li><li>增加离线口令字典攻击难度</li><li>避免被发现用户使用多个同一口令</li></ul></li><li><p>保护口令文件：影子口令文件</p></li></ul><p><strong>基于令牌的认证</strong></p><ul><li>智能卡与普通卡：<ul><li>智能卡一般是指带有接触式或者非接触式芯片的卡</li><li>普通卡一般是指普通胶印印刷的卡片，磁条、不带芯片，不具有加密感应功能，电子接口</li></ul></li></ul><p><strong>用户认证中的安全问题</strong></p><ul><li>窃听、主机攻击、重放、客户端攻击、特洛伊木马攻击、拒绝服务</li></ul><h2 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4.访问控制"></a>4.访问控制</h2><h3 id="访问控制原理"><a href="#访问控制原理" class="headerlink" title="访问控制原理"></a>访问控制原理</h3><p>访问控制：授予或拒绝下列特定要求的过程: (1) 获得并使用信息及相关信息处理服务；(2) 进入特定物理设施 。实现依据安全策略对使用系统资源进行控制，仅许可授权实体（用户、程序、进程或其他系统）依据该策略使用该系统资源。”<strong>用来实现和保证计算机系统的安全服务的措施，特别****是保证访问控制服务的措施。</strong></p><ul><li><p>自主访问控制 (DAC)</p></li><li><p>强制访问控制 (MAC)</p></li><li><p>基于角色的访问控制(RBAC)</p></li><li><p>基于属性的访问控制(ABAC)</p></li><li><p>主体：访问客体的实体</p></li><li><p>客体：外界对其访问受到控制的资源一个用来包含或接收信息的实体</p></li><li><p>访问权：描述了主体访问客体的方式</p></li></ul><h3 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h3><p><strong>定义</strong>：指一个实体可以被授权按其自己的意志使另一个实体能够访问某些资源。</p><p>访问矩阵：矩阵中的每项表示一个特定主体对一个特定客体的访问权。</p><p><strong>保护域</strong>：访问矩阵的规定，一行定义一个保护域</p><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p><strong>约束</strong>：互斥角色、基数、先决条件角色</p><h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><ul><li>优点：它的灵活性以及表达能力。</li><li>缺点：需要考虑每次访问对资源和用户属性的评价所造成的性能影响。</li></ul><p>应用：web、XAMCL（可扩展的访问扩展语言）、云服务</p><p><strong>ABAC系统能够实现 DAC、RBAC和 MAC 的思想。</strong></p><p><strong>属性</strong></p><ul><li>主体</li><li>客体</li><li>环境</li></ul><p><strong>策略</strong>：一组用来管理组织内部的允许行为的规则和关系，其基础是主体所具有的特权，以及在哪种环境条件下资源或客体需要被保护。</p><h2 id="5-数据库与云安全"><a href="#5-数据库与云安全" class="headerlink" title="5.数据库与云安全"></a>5.数据库与云安全</h2><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><ul><li>数据库：存储一个或多个应用所用的结构化数据集合</li><li>DBMS（数据库管理系统）：它是创建、维护数据 库的程序套件。为多个用户和应用提供特定的查询服务</li><li>DDL（数据定义语言）</li><li>DML（数据操纵语言）</li></ul><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p><strong>关系数据库的基本构件是数据表</strong></p><ul><li>关系数据库的结构使得多个表通过在所有表中都出现的唯一标识符联系在一起</li><li>用户和应用通过关系查询语言来访问数据库—-SQL（结构化查询语言）</li><li>关系：表&#x2F;文件  元组：行&#x2F;记录  属性：列&#x2F;字段</li><li>主键：用来唯一地标识表的一行  它由一个或多个列名组成 </li><li>外键：在一个表中定义为主键的属性必须作为另一个表的属性出现</li><li>视图&#x2F;虚表：视图是从一个或多个表中返回的选定行与列的查询结果，视图经常用于<strong>安全目的</strong>。</li></ul><h3 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h3><p><strong>用途</strong>：修改或删除数据 、 执行任意操作系统命令 、启动拒绝服务(DoS)攻击</p><p>五个<strong>类型</strong></p><ul><li>用户输入</li><li>服务器变量：HTTP头部、网络协议头部、环境变量等</li><li>二阶注入</li><li>cookie</li><li>物理用户输入</li></ul><p><strong>攻击分类</strong></p><ul><li>带内（inband）<ul><li>重言： or 1&#x3D;&#x3D;1</li><li>行尾注释</li><li>捎带查询</li></ul></li><li>推理（inferential）<ul><li>非法&#x2F;逻辑错误查询：错误返回显示</li><li>盲SQL注入：错误无显示</li></ul></li><li>带外（out-of-band）<ul><li>检索信道</li></ul></li></ul><p><strong>防御措施</strong></p><ul><li>防御性编码<ul><li>手动防御性编码实践</li><li>参数化查询插入</li><li>SQL DOM：</li></ul></li><li>检测<ul><li>基于签名</li><li>基于异常</li><li>代码分析</li></ul></li><li>运行时阻断<ul><li>在运行时检测查询是否与预期查询模型一致</li></ul></li></ul><p><strong>数据库访问控制</strong></p><p>DBMS管理策略</p><ul><li>集中管理：特权用户</li><li>基于所有权的管理：创建者可以授予和回收该表的访问权</li><li>分散管理：创建者可以给其他用户授权</li></ul><p><strong>级联授权</strong></p><p><strong>基于角色的访问控制</strong></p><p>将用户分为三类</p><ul><li>应用程序属主</li><li>应用程序属主外的终端用户</li><li>管理员</li></ul><p><strong>能力</strong></p><ul><li>创建删除角色</li><li>定义角色的许可</li><li>分配和取消用户到角色的分配</li></ul><p><strong>数据库加密</strong></p><p>缺点：</p><ul><li>密钥管理：复杂</li><li>不灵活</li></ul><h2 id="6-恶意软件"><a href="#6-恶意软件" class="headerlink" title="6.恶意软件"></a>6.恶意软件</h2><p><strong>定义</strong></p><p>一种被(往往是秘密地)植入系统中，以损害受害者数据、应用程序或操作系统的机密性、完整性或可用性，抑或对用户实施骚扰或妨碍的程序。</p><p><strong>分类</strong></p><ul><li><p>传播方式</p></li><li><p>工作方式、有效载荷</p></li><li><p>需要宿主：寄生代码、病毒</p></li><li><p>不需要宿主：蠕虫、木马、bot</p></li><li><p>可以复制：病毒、蠕虫</p></li><li><p>不可以复制：木马、垃圾邮件</p></li></ul><h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a><strong>APT</strong></h3><p><strong>高级持续性威胁</strong></p><ul><li>高级：综合性程序</li><li>持续性</li><li>威胁</li></ul><h3 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a><strong>病毒</strong></h3><p><strong>组成</strong></p><ul><li>感染机制：aka感染向量</li><li>触发条件：aka逻辑炸弹</li><li>有效载荷：</li></ul><p><strong>阶段</strong></p><ul><li>潜伏</li><li>触发</li><li>传播</li><li>执行</li></ul><p><strong>分类</strong></p><ul><li>依据目标<ul><li>感染引导区病毒</li><li>感染可执行文件病毒</li><li>宏病毒</li><li>多元复合型病毒</li></ul></li><li>依据<strong>隐蔽方式</strong><ul><li>加密型病毒</li><li>隐蔽型病毒</li><li>多态病毒</li><li>变形病毒</li></ul></li></ul><h3 id="蠕虫"><a href="#蠕虫" class="headerlink" title="蠕虫"></a>蠕虫</h3><p><strong>传播方式</strong></p><ul><li>电子邮件或即时通信工具</li><li>文件共享</li><li>远程执行能力</li><li>远程文件访问或传输能力</li><li>远程登录能力</li></ul><p><strong>扫描发现方式</strong></p><ul><li><p>扫描</p></li><li><p>随机式探索：大量流量，容易被提前中断</p></li><li><p>黑名单</p></li><li><p>拓扑式探索</p></li><li><p>本地子网</p></li></ul><p><strong>特点</strong></p><ul><li>多平台</li><li>多种攻击手段</li><li>超快速传播</li><li>多态</li><li>变形</li><li>其他恶意代码的传输载体</li><li>0-day攻击</li></ul><p><strong>客户端漏洞和路过式下载</strong>（夹带式下载）</p><p>利用应用程序中的缺陷( bug)来安装恶意软件。使得当用户浏览一个受攻击者控制的Web页面时，该页面包含的代码会攻击该浏览器的缺<br>陷并在用户不知情或未允许的情况下向系统安装恶意软件。等待那些无防备的用户浏览恶意的 Web页面来传播</p><ul><li>变种—水坑式攻击：攻击者通过研究他们意图攻击的目标，确定他们可能要浏览的Web站点，然后扫描这些站点找出那些含有能让他们植入夹带式下载的漏洞。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>社工</strong></p><ul><li>垃圾邮件</li><li>特洛伊木马</li><li>手机木马</li></ul><p><strong>Bot</strong></p><p>IRC—-&gt;HTTP</p><ul><li>与蠕虫的区别是：在于是否具有远程控制能力<br> 蠕虫是自我复制并自我激活<br> bot是由某种形式的指挥控制服务器网络控制的</li></ul><h3 id="对抗手段"><a href="#对抗手段" class="headerlink" title="对抗手段"></a>对抗手段</h3><p>恶意软件预防措施的<strong>四个要素</strong></p><ul><li>规则</li><li>警惕性</li><li>弥补弱点</li><li>缓解威胁</li></ul><p>预防失败的缓解三个措施</p><ul><li>检测</li><li>识别</li><li>清除</li></ul><p>反病毒软件的发展划分</p><ul><li>简单的扫描：通配符、特征码</li><li>启发式扫描器：另一种方法是完整性检查–校验和</li><li>活动陷阱：内存驻留程序识别病毒行为</li><li>全面保护：沙箱分析设计最困难的部分是确定执行每次解释(interpretation)所需的时间</li></ul><p><strong>方法</strong></p><ul><li>杀毒软件</li><li>砂箱分析</li><li>基于主机的行为阻断软件</li><li>间谍软件的检测和清除</li><li>边界扫描方法<ul><li>入口监控软件</li><li>出口监控软件</li><li></li></ul></li><li>分布式情报收集方法</li></ul><h2 id="7-拒绝服务攻击"><a href="#7-拒绝服务攻击" class="headerlink" title="7.拒绝服务攻击"></a>7.拒绝服务攻击</h2><p><strong>定义</strong></p><p>​DOS攻击是指利用网络协议漏洞或其它系统以及应用软件漏洞耗尽被攻击目标CPU、内存、带宽、磁盘等系统资源，使得被攻击的计算机网络无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式</p><p><strong>攻击对象</strong></p><ul><li>网络带宽</li><li>系统资源</li><li>应用资源：web</li></ul><h3 id="泛洪攻击"><a href="#泛洪攻击" class="headerlink" title="泛洪攻击"></a>泛洪攻击</h3><p><strong>目标</strong>：占据所有到目标组织的网络连接的容量</p><p><strong>分类</strong></p><ul><li>ICMP泛洪水</li><li>UDP泛洪</li><li>TCP SYN泛洪：与SYN欺骗区别：攻击的对象是数据包的总量而不是目标系统上的网络处理程序</li></ul><h3 id="SYN欺骗"><a href="#SYN欺骗" class="headerlink" title="SYN欺骗"></a>SYN欺骗</h3><p><strong>目的</strong>：系统资源；通过造成服务器上用于管理TCP连接的连接表溢出，从而攻击网络服务器响应TCP连接请求</p><h3 id="分布式拒绝服务攻击DDOS"><a href="#分布式拒绝服务攻击DDOS" class="headerlink" title="分布式拒绝服务攻击DDOS"></a>分布式拒绝服务攻击DDOS</h3><ul><li>攻击者</li><li>执行者（Zombie）</li><li>代理端（Zombie）：执行与代理通信加密 by IRC</li></ul><h3 id="基于应用的带宽攻击"><a href="#基于应用的带宽攻击" class="headerlink" title="基于应用的带宽攻击"></a>基于应用的带宽攻击</h3><ul><li>SIP洪洪</li><li>HTTP洪泛攻击</li><li>Slowloris（Based on https）：半开耗尽原理、不完整的HTTP请求（合理的HTTP流量）、现有依赖特征检测的入侵检测和入侵防御手段无法识别出Slowloris</li></ul><p><strong>防范</strong></p><p>延迟绑定、关键比特提取分析</p><h3 id="反射攻击与放大攻击"><a href="#反射攻击与放大攻击" class="headerlink" title="反射攻击与放大攻击"></a><strong>反射攻击与放大攻击</strong></h3><p>利用网络服务系统的正常功能</p><ul><li>反射攻击：<strong>防范</strong>：过滤数据包、小流量—&gt;大流量、构建回路死循环、DNS、UDP，成功的要求：生成带有虚假源地址的数据包</li><li>放大攻击：<strong>防范</strong>：防止使用虚假地址；泛洪、Smurf（ICMP）Fraggle（UDP）<strong>广播数据包</strong>—–不能用TCP，TCP面向连接无广播、DNS</li></ul><h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a><strong>防范</strong></h3><p><em>不可能完全预防DoS攻击</em></p><p>四道防线</p><p><strong>响应</strong>668</p><h2 id="8-入侵检测"><a href="#8-入侵检测" class="headerlink" title="8.入侵检测"></a>8.入侵检测</h2><h3 id="入侵者"><a href="#入侵者" class="headerlink" title="入侵者"></a>入侵者</h3><p>入侵者分类</p><ul><li>网络罪犯</li><li>活动家</li><li>国家资助的组织</li><li>其他</li></ul><p>入侵者水平分类</p><ul><li>学徒</li><li>训练有素者</li><li>高手</li></ul><p>行为分类</p><ul><li>目标获取和信息收集</li><li>初始访问</li><li>权限提升</li><li>信息收集或系统利用</li><li>维持访问权限</li><li>覆盖痕迹</li></ul><h3 id="IDS概述"><a href="#IDS概述" class="headerlink" title="IDS概述"></a>IDS概述</h3><p><strong>安全入侵</strong>：未经授权绕过系统安全机制的行为</p><p><strong>入侵检测</strong>：一种硬件或软件功能，该功能用于收集和分析计算机或网络中各个区域的信息，以识别可能的安全入侵</p><p><strong>IDS组成</strong></p><ul><li>传感器：收集数据</li><li>分析器：确认是否发生了入侵</li><li>用户接口：查看或控制系统的行为</li></ul><p><strong>IDS分类</strong></p><ul><li>HIDS基于主机的IDS：监测主机</li><li>NIDS基于网络的IDS：检测网络流量、传输、协议</li><li>分布式或混合式IDS：集成在一个中央分析器中</li></ul><p><strong>误报</strong>：对入侵性行为定义大，将用户误认为入侵者</p><p><strong>漏报</strong>：范围小，漏过真实的入侵者</p><h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><ul><li>异常检测：行为数据统计分析，<strong>可检测零日攻击</strong><ul><li>统计法</li><li>基于知识法</li><li>机器学习法</li></ul></li><li>特征或启发式检测：aka误用检测，只能识别已有的攻击<ul><li>特征方法</li><li>基于规则的启发式识别</li></ul></li></ul><h3 id="HIDS"><a href="#HIDS" class="headerlink" title="HIDS"></a>HIDS</h3><ul><li><p>数据源和传感器</p><p>​    数据源</p><ul><li>系统调用踪迹</li><li>审计记录</li><li>文件完整性校验和</li><li>注册表访问</li></ul></li></ul><p>分类</p><ul><li><p>异常HIDS</p></li><li><p>特征或启发式HIDS</p></li><li><p>分布式HIDS</p><p>组成</p><ul><li><p>主机代理模块</p></li><li><p>局域网监测代理模块</p></li><li><p>中央管理器模块：从主机代理模块和局域网监测代理模块接受并分析</p></li></ul></li></ul><h3 id="NIDS"><a href="#NIDS" class="headerlink" title="NIDS"></a>NIDS</h3><p>网络流量、传输层、网络层、应用层</p><p>组成</p><ul><li>传感器</li><li>服务器：一个或多个管理NIDS</li><li>管理控制台：一个或多个提供人机交互接口</li></ul><p>位置</p><p><strong>入侵检测技术</strong></p><p>+状态协议分析 (SPA)：缺点是它所需要的高资源占用。</p><p><strong>分布式或混合式入侵检测</strong></p><p><strong>入侵检测交换格式</strong></p><ul><li>入侵检测消息交换要求</li><li>入侵检测消息交换格式</li><li>入侵检测交换协议</li></ul><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><p>功能</p><ul><li>转移攻击者对重要系统的访问</li><li>收集有关攻击者的活动信息</li><li>引诱攻击者在系统中逗留足够长的时间，以便于管理员对此攻击做出响应</li></ul><p><em>这些系统充满了虚构的信息，这些信息看起来很有价值， 但系统的合法用户无法访问。  没有产出的资源  任何与蜜罐系统通信的尝试很可能是一个探测、扫描或者攻击。  如果一个蜜罐发起对外通信，则系统可能已被破坏</em></p><p>分类</p><ul><li>低交互蜜罐：由模拟IT服务或系统的软件包构成；无法提供所模拟服务或系统的全部功能</li><li>高交互蜜罐：完整操作系统、服务以及应用程序的真实系统；<strong>缺点</strong>：需要极大的资源，并且一旦被攻破，就可能被用来发起对其他系统的攻击</li></ul><p>位置</p><h3 id="Snort"><a href="#Snort" class="headerlink" title="Snort"></a>Snort</h3><p>体系架构</p><ul><li>数据包解码器</li><li>检测引擎</li><li>记录器</li><li>报警器</li></ul><p>规则</p><h2 id="9-防火墙"><a href="#9-防火墙" class="headerlink" title="9.防火墙"></a>9.防火墙</h2><h3 id="防火墙的必要性"><a href="#防火墙的必要性" class="headerlink" title="防火墙的必要性"></a>防火墙的必要性</h3><ul><li>对互联网连接至关重要 </li><li>保护局域网的有效手段</li><li>在驻地网络和互联网络之间插入以建立受控连接 </li><li>用作外围防御</li></ul><p><strong>设计目标</strong></p><ul><li>内外部的通信流量必须经过防火墙</li><li>只有策略授权的流量才能通过防火墙</li><li>防火墙本身不会被渗透</li></ul><p><strong>防火墙的过滤特征</strong></p><ul><li>IP地址和协议值：包过滤和状态检测</li><li>应用层协议：应用程序级网关</li><li>用户身份</li><li>网络活动</li></ul><p><strong>局限性</strong></p><ul><li>无法组织绕开防火墙的攻击</li><li>无法完全组织内部威胁</li><li>不正确的安全无线局域网可以从组织外部访问 </li><li>内部人员沾花惹草</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><strong>包过滤防火墙</strong></p><p>规则</p><ul><li>源ip 目的ip</li><li>源&#x2F;目的传输层地址</li><li>IP协议域</li><li>接口</li></ul><p>两种策略</p><ul><li><p>丢弃：阻止没有明确准许（保守可控，对用户可见）</p></li><li><p>转发：准许没有明确拒绝（易于管理使用，安全性差）</p></li><li><p>优点：简单；用户透明；处理速度快</p></li><li><p>缺点：无法阻止上层攻击（具体说）、有限的日志功能、不支持高级用户认证、易受TCP&#x2F;IP协议漏洞攻击（源地址欺骗）、配置不当会导致破坏</p></li></ul><p>攻击</p><ul><li>IP欺骗</li><li>源路由攻击</li><li>IP细小分段</li></ul><p><strong>状态检测防火墙</strong></p><p><em>通过建立一个出站TCP连接目录来强制执行TCP流量的规则</em></p><p><strong>应用级网关</strong></p><p><em>aka应用程序代理</em></p><ul><li>优点：比包过滤更安全</li><li>缺点：增加每个连接上的额外处理开销</li></ul><p><strong>电路级网关</strong></p><p><em>aka电路级代理</em></p><p>e2e—&gt;两条连接;不检查内容；确定哪些连接被允许；通常在信任内部用户时使用；较低的管理费用</p><h3 id="防火墙的布置"><a href="#防火墙的布置" class="headerlink" title="防火墙的布置"></a>防火墙的布置</h3><p>（优缺点记一下）</p><ul><li>堡垒主机 <em>：系统被认为是网络安全的一个关键强点 作为应用级或电路级网关的平台</em></li><li>基于主机的防火墙</li><li>个人防火墙</li></ul><h4 id="防火墙的部署与配置"><a href="#防火墙的部署与配置" class="headerlink" title="防火墙的部署与配置"></a>防火墙的部署与配置</h4><p><strong>DMZ</strong></p><p><em>外防火墙和内防火墙之间的区域</em></p><p><strong>VPN</strong></p><p>虚拟专用网络</p><p><strong>分布式防火墙</strong></p><p><strong>防火墙部署和拓扑结构</strong></p><p>（记一下各个图）</p><h3 id="IPS入侵防御系统"><a href="#IPS入侵防御系统" class="headerlink" title="IPS入侵防御系统"></a>IPS入侵防御系统</h3><p><em>aka IDPS入侵检测和防御系统</em></p><p>分类同上；策略2中（特启&#x2F;异）</p><p><strong>HIPS</strong></p><p><strong>NIPS</strong>识别恶意数据包的方法</p><ul><li>模式匹配</li><li>传输异常</li><li>状态匹配</li><li>统计异常</li><li>协议异常</li></ul><p><strong>数字免疫系统</strong></p><p>IBM开发、全方面防御</p><p><strong>Snort Inline</strong></p><p>snort的改进版</p><p>规则：丢弃、拒绝、简单丢弃（不做记录）、对蜜罐实现有用  </p><p>攻击者看到了失败，但不能找出它发生的原因 </p><p><strong>一体化威胁管理系统</strong></p><h2 id="10-缓冲区溢出"><a href="#10-缓冲区溢出" class="headerlink" title="10.缓冲区溢出"></a>10.缓冲区溢出</h2><p><strong>防御措施</strong></p><ol><li>编译时防御：加固程序来抵抗在新程序中的攻击<ul><li>使用现代高级程序语言–自动检查越界、额外资源销</li><li>安全的编码技术    </li><li>语言扩充和安全库的使用</li><li>栈保护机制：设定函数入口和出口代码并检查其栈帧寻找有没有受到破坏的证据、stackguard（栈卫士）、Stackshield和返回地址防护者 (RAD)、随机的canary（金丝雀）值</li></ul></li><li>运行时防御：在现有的程序中检测和终止攻击<ul><li>可执行地址空间保护：虚拟内存保护栈和堆</li><li>地址空间随机化</li><li>Guard 页（隔开）：在进程的地址空间的关键区域、在栈帧之间，或者是在堆的不同的存储区域之间设置guard页；耗费时间和页需求</li></ul></li></ol><p><strong>攻击形式</strong></p><ul><li>栈溢出</li><li>替换栈帧</li><li>返回到系统调用</li><li>堆溢出</li><li>全局数据区溢出</li></ul><h2 id="11-软件安全-888"><a href="#11-软件安全-888" class="headerlink" title="11.软件安全 888"></a>11.软件安全 888</h2><h2 id="12-操作系统安全"><a href="#12-操作系统安全" class="headerlink" title="12.操作系统安全"></a>12.操作系统安全</h2><h2 id="13-云安全"><a href="#13-云安全" class="headerlink" title="13.云安全"></a>13.云安全</h2><h2 id="16"><a href="#16" class="headerlink" title="16."></a>16.</h2><h2 id="17"><a href="#17" class="headerlink" title="17."></a>17.</h2><h2 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h2><h2 id="20"><a href="#20" class="headerlink" title="20."></a>20.</h2>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/01/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20/"/>
      <url>/2025/01/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="[操作系统]"></a>[操作系统]</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.并发 并行 多道特征（关键词固定 填空或者简答）</span><br><span class="line">特征需要好好背。实时系统的软硬</span><br><span class="line">文件系统分为？  操作系统的主要功能 进程的组成（pcb 栈什么 填空题） 信息安全不在考试范围内。以选择题出现了解即可。   最容易丢用户接口。 操作系统的基本特征重中之重 掌握圆盘里面的每一个概念 每一个概念可能会展开说。    谁最重要：并发性 1.4基本没咋考过</span><br><span class="line"></span><br><span class="line">2.第二章四十分以及更多</span><br><span class="line">同步最重要 死锁的避免预防接触不是一回事 住意选择题的混淆。  进程的pcb干什么的 原语和原子操作。7状态模型 哪些状态不可达和可达 为什么可达。图会画 箭头。  顺序性 封闭性这几个性质要掌握 填空题</span><br><span class="line">理解进程的特征。进程=balabla+balala。段不可忽略 选择题要注意！！！   交换和覆盖这一对也考的多。  挂起和阻塞考选择题（/什么会导致balabala） pcb里面包含的东西三个 常出。   模式（用户和内核 选择 以下哪个会导致模式的切换  原语很重要！！！ 进程的切换考得很多（以下哪个操作引起进程的切换 比较好的时机 选择题）。fork也考过很多次 很重要 易错点for循环后面的分号的位置 作业和进程调度区别 填空 作业调度的三种方式 长程 中 短   注意索引表的大小不能忽略 内核功能了解 注意一下两个模式切换。进程控制四种的什么会引起。   注意何时会发生进程切换 选择题会考。 程序阅读会考到fork 编程一般不会出现   线程和进程的区别 调度周转时间等等的计算 各种公式的定义 带不带抢占很重要 题干没要求作图可以不做图 进程和死锁可能有的是银行家算法 信号量编程必出。 什么小屋改进程序阅读能否实现改进，ppt上是互斥礼让。   整型信号量的问题 and信号量进餐。  信号量实现同步和互斥20分 管程还要学 可能性很大考。重中之重生产者消费者问题！ 几个经典模型 死锁的检测避免解除不是一回事</span><br><span class="line"></span><br><span class="line">3.分区分配算法填空选择。紧凑和重定位 伙伴了解 覆盖和交换很重要 四到六个计算题 本章的计算题主要在分页 多级页表考了很多年 选择题级数多应用题一般两级。容易忽略快表！拉开差距！ 置换策略也是重点 belady现象</span><br><span class="line"></span><br><span class="line">4.三个io控制方式 具体流程考的在填空选择</span><br><span class="line">各种词汇都可能考 拿高分 磁盘调度的算法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">信号量的题提前申明寄存器</span><br><span class="line">看清是不是虚拟！！！！！！！！！！！！！！</span><br></pre></td></tr></table></figure><h2 id="系统综述"><a href="#系统综述" class="headerlink" title="系统综述"></a>系统综述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">五个功能</span><br><span class="line">处理机管理</span><br><span class="line">存储器管理</span><br><span class="line">设备管理</span><br><span class="line">文件管理</span><br><span class="line">提供用户接口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>中断</strong></p><p><a href="https://blog.csdn.net/qq_26553393/article/details/122239406">1.1.5 中断的概念和作用、内部中断、外部中断、中断机制的基本原理_处理器中断-CSDN博客</a></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何提高内存利用率</span><br><span class="line">1.减少内外碎片</span><br><span class="line">2.交换</span><br><span class="line">3.共享分配</span><br></pre></td></tr></table></figure><ul><li>便利性</li><li>有效性</li><li>扩展能力</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>操作系统是指控制管理整个计算机系统的硬件和软件资源的程序集合，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件—-OS是由处理器执行的<strong>程序集合</strong></p><ul><li>系统资源的管理者</li></ul><p>​将进程放入内存进行执行</p><ul><li><p>向上层提供方便易用的服务</p></li><li><p>作为最接近硬件的层次</p></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p><strong>最重要，其他特征的前提</strong></p><ul><li>并发：两个或者多个事件同一时间间隔内发生  宏观上同时发生，微观上交替发生  </li><li>并行：两个或多个事件在同一时刻同时发生</li></ul><hr><ul><li>程序：静态实体，无法并发</li><li>进程：动态实体，可以并发</li></ul><hr><ul><li>单处理机系统：进程可并发执行，无法并行执行</li><li>多处理机系统：进程既可并发执行，又可并行执行</li></ul><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>系统中的资源可供内存中多个并发的进程<strong>共同</strong>使用</p><p>并发和共享互为存在条件</p><p>类型</p><ul><li>临界资源：在一段时间内，只允许一个进程访问</li><li>非临界资源：在一段时间内，允许多个进程访问</li></ul><p>共享方式</p><ul><li>互斥访问共享：对临界资源的访问，如打印机</li><li>同时访问共享：对非临界资源的访问，如磁盘</li></ul><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ul><li>时分复用技术：虚拟处理器、虚拟设备（打印机：SPOOLING技术）</li><li>空分复用技术：虚拟磁盘、内存</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>AKA：不确定性质</p><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>通常而言，操作系统的<strong>不确定性是指异步性</strong>，<strong>而非</strong>程序执行结果的不确定性。</p><hr><h3 id="易发展性"><a href="#易发展性" class="headerlink" title="易发展性"></a>易发展性</h3><ul><li>硬件升级和新型硬件的出现</li><li>新设备、服务的出现</li><li>错误修复、纠正</li></ul><h3 id="发展分类"><a href="#发展分类" class="headerlink" title="发展分类"></a>发展分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">吞吐量=总量/总时间</span><br></pre></td></tr></table></figure><p><strong>关心的目标</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">批处理：吞吐时间和周转时间</span><br><span class="line">交互式：响应时间</span><br><span class="line">实时：截止时间</span><br></pre></td></tr></table></figure><p><strong>交互式和批处理</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">批处理：脱机控制或者自动控制，用户使用操作系统提供的作业控制语言写 控制说明书，连程序和数据一起交给OS</span><br><span class="line">交互式：联机控制方式。使用操作系统提供的 操作控制命令，逐条输入命令控制作业执行，适用终端用户，来自终端的作业交终端作业</span><br></pre></td></tr></table></figure><h4 id="串行处理"><a href="#串行处理" class="headerlink" title="串行处理"></a>串行处理</h4><p>问题：调度、启动准备时间、无操作系统、控制台运行、输入设备（卡片阅读）载入计算机、顺序访问</p><h4 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h4><p>​监控程序、一次处理一道作业、运行模式：用户和内核；问题：CPU大量时间空闲 因为Io速度比CPU慢</p><p>​<strong>监控程序的功能</strong>：</p><p>​自动续接下一个作业</p><p>​内存保护：保护监控程序所在的内存区域</p><p>​定时器：防止作业独占系统</p><p>​特权指令：监控程序的指令：IO</p><p>​中断</p><p>​</p><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><ul><li>多个作业并发执行</li><li>作业调度程序负责调度</li><li>硬件支持：I&#x2F;O中断、直接存储器访问（DMA）</li><li>特征：多道性、调度性、无序性、<strong>无交互能力</strong></li><li>会在内存中产生碎片</li><li><strong>目的—–<strong>提高</strong>资源的利用率</strong>和<strong>系统吞吐量</strong></li></ul><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><ul><li><p>仍然采用<strong>多道程序设计技术</strong></p></li><li><p>多用户各自独立、通过不同终端、同时共享处理器、各自不干扰</p></li><li><p>特征：多路性、独立性、<strong>及时性</strong>、<strong>交互性</strong>—-引入终端命令解释程序接受用户的命令，解释命令并执行还需要系统调用功能</p></li><li><p>第一个分时OS：CTSS</p></li></ul><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><ul><li>及时响应</li><li>分类：如下，大多系统是二者结合</li><li>实时系统的特征**：实时性**、可靠性、多路性、独立性、交互性（比分时差）</li></ul><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>一段可执行的程序</li><li>程序所需要的相关数据（变量、工作空间、缓冲区等）</li><li>程序的执行上下文（execution context）<br>➢ 也称进程状态（process state）<br>➢ 操作系统用来管理和控制进程所需的所有数据</li></ul><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>内存管理的任务</p><ul><li>进程隔离：每个进程空间独立、互不干扰</li><li>自动分配和管理：OS动态分配、对程序员透明</li><li>模块化程序设计</li><li>保护和访问控制</li><li>永久存储</li></ul><p>实现方式：文件管理+虚拟内存</p><p>文件管理</p><ul><li>文件系统实现长期存储</li><li>文件：有名称的对象，<strong>保护和访问控制的基本单元</strong></li></ul><p>虚拟内存</p><ul><li>程序以逻辑方式访问存储器</li><li>多作业同时驻留内存</li><li>– 每个作业部分驻留</li><li>– 换入、换出机制</li></ul><h4 id="信息保护安全"><a href="#信息保护安全" class="headerlink" title="信息保护安全"></a>信息保护安全</h4><ul><li>可用性</li><li>保密性</li><li>数据完整性</li><li>可靠性</li></ul><h4 id="调度和资源管理"><a href="#调度和资源管理" class="headerlink" title="调度和资源管理"></a>调度和资源管理</h4><ul><li>公平性</li><li>有差别的响应性</li><li>有效性：吞吐量和响应时间的折中</li></ul><h3 id="目标功能"><a href="#目标功能" class="headerlink" title="目标功能"></a>目标功能</h3><ul><li><p>处理机功能：进程、调度</p></li><li><p>存储器管理：</p></li><li><p>设备管理</p></li><li><p>文件管理</p></li><li><p>用户接口：</p><ul><li>命令接口：联机命令接口（实时）和脱机命令接口（批处理）</li><li>程序接口（系统调用–（广义指令））</li></ul></li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul><li><p>无结构</p></li><li><p>模块化结构</p></li><li><p>分层式结构</p><ul><li>单向依赖关系：每层只能使用其直接下层所提供的服务 每层对其上层隐藏其下各层的存在</li><li>缺点：效率低</li></ul></li><li><p>微内核</p></li></ul><p>​</p><pre><code>内核保留基本功能、C\S模式</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高级通信机制归结为三大类</span><br><span class="line">共享存储器系统</span><br><span class="line">消息传递</span><br><span class="line">管道通信</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程切换一定发生模式切换</span><br><span class="line">模式切换不一定发生进程切换</span><br></pre></td></tr></table></figure><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><strong>状态</strong></p><ul><li><p>提交状态</p></li><li><p>后备状态：作业输入到OS缓冲池等待调度调入<strong>内存</strong>的状态</p></li><li><p>运行状态：在缓冲池中的作业由调度算法调入内存，<strong>创建为进程，变为运行态</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS:内存中进程的调度是微观调度，对于作业来说只要被调入内存创建进程后宏观上就是运行状态</span><br></pre></td></tr></table></figure></li><li><p>完成状态：运行结束或者错误终止</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程性质：动态性（最基本特征）、并发性、独立性、异步性（同步的原因）</span><br></pre></td></tr></table></figure><h3 id="顺序执行和并发执行"><a href="#顺序执行和并发执行" class="headerlink" title="顺序执行和并发执行"></a>顺序执行和并发执行</h3><p>顺序</p><ul><li>顺序性</li><li>封闭性：执行的程序独占资源，不会被打断</li><li>可再现性</li><li>表示：有向无循环图</li></ul><p>并发</p><p>两个或者多个事件同一时间间隔内发生  宏观上同时发生，微观上交替发生</p><ul><li>间断性</li><li>失去封闭性</li><li>不可再现性</li></ul><p><u>引入进程的目的是使多道程序能够正确地并发执行</u></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>一个正在<strong>执行</strong>的程序。</li><li>一个正在计算机上<strong>执行</strong>的程序实例。</li><li>一个能够被调度到处理器上<strong>执行</strong>的实体。</li><li>由一串指令的<strong>执行</strong>、当前状态和一组正在使用的系统资源表征的活动单元</li></ul><hr><ul><li><p>程序：静态的、存放在磁盘里的可执行文件，就是一组有序指令集合；永久</p></li><li><p>进程：动态的，程序的一次执行过程，同一个程序多次执行会对应多个进程；具有生命周期</p></li></ul><p>​进程和程序不是一一对应—-n:m</p><p>​一个程序开始运行前,需要创建对应的进程,也就要创建相应的PCB</p><p><strong>对比</strong></p><ul><li>动态性：进程具有动态性、生命周期；程序只是一组有序指令集合，静态实体。</li><li>并发性：进程可以并发；程序不可以</li><li>独立性：进程实体是一个能独立运行的基本单位，调度和资源分配的基本单位；未被建立进程的程序不能作为独立的单位参加运行</li></ul><hr><p>引入进程带来的开销：空间（数据结构）、时间、控制复杂性</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p>PCB：进程控制块—–<strong>由OS创建管理使用</strong>  <strong>常驻内存</strong>  <strong>进程存在的唯一标志</strong> <strong>OS根据PCB来对并发执行的进程进行控制管理</strong></p><ul><li><p>标示符:pid</p></li><li><p>状态</p></li><li><p>优先级</p></li><li><p>程序计数器</p></li><li><p>内存指针</p></li><li><p>上下文数据</p></li><li><p>I&#x2F;O状态信息</p></li><li><p>记账信息</p></li></ul><hr><p><strong>PCB的属性</strong>可分为三类</p><ul><li><strong>进程标识符</strong>：PID、父id，Uid（创建进程的用户）</li><li><strong>处理机状态信息</strong>：通用寄存器（用户可见寄存器）、控制和状态寄存器、栈</li><li><strong>进程控制信息</strong>：优先级、数据结构、通信、特权、存储、资源使用权</li></ul><hr></li><li><p>程序段：程序的代码（指令序列）—-多个子进程的代码可能一样（3个qq）</p></li><li><p>数据段：运行过程中产生的各种数据  </p></li><li><p>栈</p></li></ul><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul><li>动态性：<strong>最基本</strong>、动态地产生变化消亡</li><li>并发性</li><li>独立性</li><li>异步性:各自独立的推进</li></ul><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><strong>五状态模型</strong></p><ul><li>创建态（新建态）：关于该进程的信息、进程标识符在内存的进程表中，也没有为与这个程序相关的数据分配空间，但进程还在外存</li><li>就绪态：当进程已分配到<strong>除CPU以外</strong>的所有必要资源后，只要再获得CPU，便可立即执行进程。</li><li>运行态：一个CPU只会有一个进程处于运行态，多核CPU才可以有多个进程处于运行态</li><li>阻塞态（等待态）：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行进程。</li><li>终止态：表格和其它信息暂时保留</li><li></li></ul><p><strong>交换技术</strong></p><p>​内存中没有就绪进程或内存空间非常<strong>紧张</strong>时，系统将内存中<strong>暂时不能运行</strong>的进程，或暂时不用的数据和程序，Swapping-out<strong>到外存</strong>，以腾出足够的内存空间，把已具备运行条件的进程或进程所需要的数据和程序，Swapping-in<strong>到内存</strong>。</p><p><strong>挂起</strong></p><p>概念：将<strong>内存中</strong>处于阻塞、就绪、甚至是执行状态的进程放到外存，不再参与CPU的竞争</p><p>原因</p><ul><li>交换</li><li>OS主动挂起</li><li>进程全部阻塞，CPU空闲</li><li>调试</li><li>父进程请求</li></ul><p><u><strong>激活挂起</strong>进程的进程就是<strong>实施挂起</strong>操作的进程</u>——解铃还须系铃人</p><p><strong>七状态模型</strong></p><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><ul><li>链接方式：OS指针指向队列，多级队列和单一队列</li><li>索引方式：OS指针指向索引表</li></ul><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p><strong>内核态</strong>、系统态、特权态、管态</p><ul><li>资源管理功能：进程管理、内存管理、IO管理</li><li>支撑功能：中断，记账、监视、时钟管理</li><li>可以执行指令系统的全集</li></ul><p><strong>用户态</strong>、常态、目态</p><p>双模式为了：<strong>保护操作系统和重要的操作系统表（如PCB）不受程序干扰</strong></p><p>程序状态字PSR寄存器中存在指示执行模式的位</p><p>模式切换不一定会必然导致进程切换</p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>进程控制就是实现进程状态的转换、由原语来实现</p><hr><p><strong>创建</strong></p><ol><li>触发事件</li></ol><ul><li>用户登录</li><li>作业调度：为被调度的作业分配进程</li><li>提供服务：打印机</li><li>已有进程请求：由现有进程派生</li></ul><p>​2.过程</p><ul><li><p>OS调用创建原语</p></li><li><p>分配唯一进程标识符</p></li><li><p>分配地址空间</p></li><li><p>初始化PCB</p></li><li><p>建立链接：插入就绪或者就绪挂起队列</p></li><li><p>建立或扩充其他数据结构</p></li></ul><p><strong>create（）</strong></p><p><strong>终止</strong></p><ol><li>触发事件<ul><li>正常结束</li><li>异常错误：越界错误 • 保护错误 • 非法指令 • 特权指令错 • 运行超时 • 等待超时 • 算术运算错、被0除 • I&#x2F;O故障</li><li>外界干预：Admin干预、父进程被终止、父进程终止</li></ul></li></ol><p>​2.过程</p><ul><li><p>OS调用撤销7原语</p></li><li><p>根据PCB读取状态</p></li><li><p>终止执行，调度下一个就绪进程执行</p></li><li><p>终结子进程，向系统或父进程归还资源</p></li><li><p>从对应的队列中移除PCB</p></li></ul><hr><p><strong>阻塞</strong></p><p>1.触发事件</p><ul><li>请求的系统服务得不到满足</li><li>访问临界资源</li><li>等待另一进程执行结果</li><li>无新工作可做</li></ul><p>阻塞原语block**()**</p><p><strong>唤醒</strong></p><p>1.触发事件</p><ul><li>阻塞事件发生</li></ul><p>唤醒原语wakeup()</p><hr><p><strong>挂起</strong></p><p>suspend( )</p><p><strong>激活</strong></p><p>active()</p><hr><p><strong>切换</strong></p><p>1.触发事件</p><ul><li>时钟中断</li><li>IO中断（不一定）</li><li>内存失效</li><li>陷阱：指令异常或错误</li><li>系统调用</li></ul><p>2.过程</p><ul><li>保存上下文 ，程序计数器和寄存器</li><li>更新当前执行的PCB，移动到新的队列</li><li>选择另外进程执行，更新PCB，移动队列</li><li>恢复上下文环境</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行态---就绪态：1.时间片用完 2.高优先级抢占</span><br></pre></td></tr></table></figure><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>inter-process communication（IPC）</p><ul><li>各进程拥有的内存地址空间相互独立</li></ul><p>共享存储—最快的</p><ul><li>两个进程在内存中申请一片共享存储区，映射到自己的地址空间</li><li>需要保证两个进程对共享空间的访问是<strong>互斥</strong>的（P、V）操作</li><li>基于存储区共享：高级通信，速度快，数据形式以及位置由进程控制</li><li>基于数据结构：低级</li><li>没有用到操作系统</li></ul><p>消息传递</p><ul><li>报文格式化传递（消息头+消息体）</li><li></li><li>直接通信（标明ID）</li><li></li><li>间接通信（通过信箱）</li></ul><p>管道通信</p><ul><li>单向通信（半双工通信）</li><li>pipe文件，实质是内存中开辟一个大小固定的内存缓冲区</li><li>管道中的信息先进先出，信息按队列式存储（区别与共享存储），循环队列</li><li>各进程的管道访问互斥（由OS实现）</li><li>管道满（空），写（读）进程阻塞</li><li>多个读会混乱-&gt;解决方案：1.（主）多个写一个读 2.多个写多个读，OS让各个读进程轮流读取（Linux）</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><p>轻量级进程(LWP)</p></li><li><p>实现进程内部的并发</p></li><li><p>进程是资源分配的基本单位，线程是调度的基本单位，线程的切换开销较小</p></li><li><p>拥有少量私有资源<br>⚫ 线程控制块(含PC、寄存器、线程状态等信息)、栈等</p></li><li></li></ul><p>相比进程的<strong>优点</strong></p><ul><li><p>进程可以并发不可以并行；进程可以并发也可以并行</p></li><li><p>创建、结束开销和时间</p></li><li><p>切换的速度块</p></li><li><p>相同的地址空间，通信快</p></li><li><p>有些进程的操作无需内核干预</p></li></ul><h3 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h3><p>就绪、执行、阻塞</p><p>一般没有挂起态度</p><h3 id="操作功能"><a href="#操作功能" class="headerlink" title="操作功能"></a>操作功能</h3><ul><li>派生：创建进程-&gt;线程、线程-&gt;线程</li><li>阻塞</li><li>解除阻塞</li><li>结束</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户级线程：调度实体是线程映射到内核上的实体</span><br><span class="line">内核级线程：每个线程都是处理机调度的实体</span><br></pre></td></tr></table></figure><p><strong>用户级线程</strong></p><ul><li>早期</li><li>由应用程序通过线程库实现，非OS</li><li>线程切换只需要在用户态下，无需切换核心态，系统开销小效率高</li><li>OS不能看到用户级线程存在，OS眼中只有进程，OS看操作以进程为单位</li><li>缺点：**并发度不高 **  一个线程阻塞会造成整个进程阻塞，</li><li>即使多核CPU，一个进程对应一个CPU，线程无法并发</li><li>切换速度更快</li><li>线程数目增加，进程速度降低</li><li><pre><code>调度时，系统调度执行时间只用一个时间片<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**内核级线程**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 基于OS管理</span><br><span class="line"></span><br><span class="line">- 线程的切换需要CPU变态</span><br><span class="line"></span><br><span class="line">- 优点：并发性强，不会因为单个线程的阻塞影响进程</span><br><span class="line"></span><br><span class="line">- 线程是CPU调度的基本单位，进程是分配资源的基本单位</span><br><span class="line"></span><br><span class="line">- 缺点：一个进程占用多个内核线程，管理成本高，切换开销大</span><br><span class="line"></span><br><span class="line">- 线程数目增加，进程速度增加</span><br><span class="line"></span><br><span class="line">- 用户级线程即使多处理机也无法实现线程并行；内核级线程多处理机可以实现真正的线程并行</span><br><span class="line"></span><br><span class="line">  ---</span><br><span class="line"></span><br><span class="line">  补充</span><br><span class="line"></span><br><span class="line">- TCB（线程控制块）</span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">## 调度</span><br><span class="line"></span><br></pre></td></tr></table></figure>调度开始主要针对运行态</code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 分类</span><br><span class="line"></span><br><span class="line">- 长程调度（高级调度、作业调度）：新建----&gt;就绪 /就绪挂起、选后备队列中的作业为其创建进程</span><br><span class="line">- 中程调度（中级调度、内存调度）：外存-&gt;内存、交换、有挂起功能的系统才有中程调度、挂起-&gt;就绪/阻塞------为了提高内存利用率和系统吞吐量引进</span><br><span class="line">- 短程调度（低级调度、进程调度）：内存-&gt;CPU、就绪队列--&gt;处理器，产因（时钟中断、IO中断、系统调用、信号量）、最频繁</span><br><span class="line">- ```</span><br><span class="line">  进程调度主要针对就绪队列：1.进程完成过工作后被撤销 2.运行态到就绪态或者阻塞态 3.阻塞态到就绪态</span><br></pre></td></tr></table></figure><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ul><li><p>非剥夺调度方式（非抢占方式）：早期，开销小，无法处理紧急任务、批处理</p></li><li><p>剥夺调度方式（抢占方式）：适合分时</p></li><li><pre><code>抢占：1.优先级高 2.短进程到达 3.时间片用完1、2必须通过运行的进程激活调度线程才可以重新调度，否则难以完成抢占3由时间片用完后硬件中断进行调度  所以时间片轮转是绝对抢先的算法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>只进程调度：RR、优先级调度、多级反馈队列进程&amp;作业调度：FCFS、SJF/SPF、HRRN<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>进程时间片用完可以降低其优先级；完成IO进程应提升其优先级；处于就绪队列等待调度的进程一般不会改变其优先级<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 评价指标</span><br><span class="line"></span><br><span class="line">- CPU利用率：busy time/whole time</span><br><span class="line">- 系统吞吐量：作业/时间</span><br><span class="line">- 周转时间（For user，越小越好）：作业完成的时间-作业提交给系统的时间</span><br><span class="line">- 平均周转时间：（For OS）各个作业周转时间之和/作业数</span><br><span class="line">- 带权周转时间（&gt;=1,越小越好）：周转时间/作业实际运行的时间</span><br><span class="line">- 平均带权周转时间：各个作业带权周转时间之和/作业数</span><br><span class="line">- 等待时间（越小越好）：等待CPU处理的时间之和（作业的等待时间因为包含等待I/O完成时间，**进程的等待时间不包括I/O**,所以大于进程的等待时间）</span><br><span class="line">- 响应时间：user提出请求到响应的时间</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">面向用户的规则：响应时间、周转时间、截止时间</span><br><span class="line"></span><br><span class="line">面向系统的规则：吞吐量、利用率、公平性、优先级</span><br><span class="line"></span><br><span class="line">### 调度算法</span><br><span class="line"></span><br><span class="line">FCFS（先来先服务）</span><br><span class="line"></span><br><span class="line">- 考虑作业先到达**后备队列**（在外存），进程先到达**就绪队列**（在内存）</span><br><span class="line">- 非抢占式算法</span><br><span class="line">- 优点：公平简单</span><br><span class="line">- 缺点：对于一个排在长进程或者作业的短作业或者进程，用户体验不好（奶茶店）</span><br><span class="line">- 不会导致饥饿</span><br><span class="line"></span><br><span class="line">SJF（SPF）（短作业（进程）优先）</span><br><span class="line"></span><br><span class="line">- 非抢占</span><br><span class="line">- 抢占式（SRTN）：**最短的平均等待、周转时间**</span><br><span class="line">- 不断地短进程进入，可能会导致**饥饿**</span><br><span class="line"></span><br><span class="line">HRRN（高响应比优先）-----**人机交互**</span><br><span class="line"></span><br><span class="line">- 响应比：（等待时间+要求服务时间）/要求服务时间</span><br><span class="line">- 非抢占</span><br><span class="line">- 不会导致饥饿</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">时间片轮转（RR）</span><br><span class="line"></span><br><span class="line">交互</span><br><span class="line"></span><br><span class="line">- 用于进程调度，只有作业放入内存建立相应的进程才能被分配处理机的时间片</span><br><span class="line">- 抢占式，由时钟中断剥夺时间</span><br><span class="line">- 用于分时操作系统，关心响应时间，不计算周转时间</span><br><span class="line">- 时间片不能太大，切换进程的开销不超过1%</span><br><span class="line">- 优点：公平，响应快</span><br><span class="line">- 缺点：增大开销，不区分紧急</span><br><span class="line">- 不会导致饥饿</span><br><span class="line"></span><br><span class="line">优先级调度算法</span><br><span class="line"></span><br><span class="line">- 作业进程I/O调度</span><br><span class="line">- 抢占|非抢占</span><br><span class="line">- 抢占式就绪队列中的优先级不是由谁先到达决定，由优先权值决定</span><br><span class="line">- 系统进程&gt;用户进程</span><br><span class="line">- 前台进程&gt;后台进程</span><br><span class="line">- I/O繁忙型进程&gt;CPU繁忙型进程（计算型进程）</span><br><span class="line">- 优点：灵活调整，实时操作系统，适合紧急重要</span><br><span class="line">- 会导致饥饿</span><br><span class="line"></span><br><span class="line">多级反馈队列调度算法</span><br><span class="line"></span><br><span class="line">- 进程调度</span><br><span class="line">- 抢占式</span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  并发互斥</span><br><span class="line"></span><br><span class="line">### 概念</span><br><span class="line"></span><br><span class="line">- 临界区：把在每个进程中访问临界资源的那段代码称为临界区</span><br><span class="line"></span><br><span class="line">- 临界资源：一个时间段内只允许一个进程使用的资源，eq：物理设备等</span><br><span class="line">- ```</span><br><span class="line">  进程在操作系统内核程序临界区不能进行调度与切换，在普通临界区能够调度与切换</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>并发进程之间存在信息交换时，一定共享某些资源<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 互斥：当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问共享资源</span><br><span class="line">- 死锁：两个或两个以上的进程相互等待导致都不能执行</span><br><span class="line">- 竞争：多个进程读写一个共享变量，该变量的最终值依赖它们执行的相对速度</span><br><span class="line">- 饥饿：一个进程已经完全具备了执行的条件，但是得不到CPU资源</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">### 原则</span><br><span class="line"></span><br><span class="line">- 空闲让进：当没有进程在临界区时，允许一个请求进入临界区的进程进入临界区</span><br><span class="line">- 忙则等待：当临界区存在进程，其他想要进入临界区的的进程必须等待</span><br><span class="line">- 有限等待：对于一个进入临界区的请求，应当在有限时间内得到满足</span><br><span class="line">- 让权等待：进程不能进入临界区时，应当释放调处理机资源</span><br><span class="line"></span><br><span class="line">### 软件算法</span><br><span class="line"></span><br><span class="line">**单标志法**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**双标志先检查法**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**双标志后检查法**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Peterson算法**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 互斥的硬件实现方法</span><br><span class="line"></span><br><span class="line">#### 中断屏蔽方法</span><br><span class="line"></span><br><span class="line">- 优点：简单高效</span><br><span class="line">- 缺点：不适用多处理机；只适用内核进程，不适用于用户进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### TestAndSet（Lock）TSL指令</span><br><span class="line"></span><br><span class="line">- 一气呵成、**原子**操作，简单，适用于多处理机</span><br><span class="line">- 不满足让权等待</span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">#### Swap(Exchange)(XCHG)指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 信号量机制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**软件和硬件都需要循环等待**</span><br><span class="line"></span><br><span class="line">- 原语+信号量</span><br><span class="line">- 一对原语：wait(S) &amp; signal(S) [proberen （尝试）&amp; verhogen（增加）]  [P(S) &amp; V(S)]</span><br><span class="line"></span><br><span class="line">#### 整型信号量</span><br><span class="line"></span><br><span class="line">**未实现让权等待**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####  记录型信号量（semaphore）</span><br><span class="line"></span><br><span class="line">**满足四条准则**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">单缓冲不用mutex进行互斥</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 生产者消费者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多生产消费者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 吸烟者问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>semaphore offer1 = 0;//提供卷纸和火柴semaphore offer2 = 0;//提供火柴和烟草semaphore offer3 = 0;//提供卷纸和烟草semaphore finish = 1;//通知供应者继续提供材料</code></pre></li></ul><p>&#x2F;&#x2F;供应者进程<br>Provider(){<br>    int rand;<br>    while(true){<br>        P(finish);<br>        rand &#x3D; getRandom()%3;<br>        if(rand &#x3D;&#x3D; 0){<br>            V(offer1);<br>        }else if(rand &#x3D;&#x3D; 1){<br>            V(offer2);<br>        }else{<br>            V(offer3);<br>        }<br>    }<br>}</p><p>&#x2F;&#x2F;吸烟者1<br>Smoker1(){<br>    while(true){<br>        P(offer1);<br>        制作香烟并消耗；<br>        V(finish);&#x2F;&#x2F;通知供应者继续提供材料<br>    }<br>}</p><p>&#x2F;&#x2F;吸烟者1<br>Smoker2(){<br>    while(true){<br>        P(offer2);<br>        制作香烟并消耗；<br>        V(finish);&#x2F;&#x2F;通知供应者继续提供材料<br>    }<br>}</p><p>&#x2F;&#x2F;吸烟者3<br>Smoker3(){<br>    while(true){<br>        P(offer3);<br>        制作香烟并消耗；<br>        V(finish);&#x2F;&#x2F;通知供应者继续提供材料<br>    }<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 读写者问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 管程</span><br><span class="line"></span><br><span class="line">- 一种高级的同步操作</span><br><span class="line"></span><br><span class="line">**组成**</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 死锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">T**IPS：**</span><br><span class="line"></span><br><span class="line">- 参与死锁的进程不一定都占有资源，一定都等待资源</span><br><span class="line">- 死锁可以发生在无关进程和相关进程之间</span><br><span class="line"></span><br><span class="line">#### 产生条件：</span><br><span class="line"></span><br><span class="line">- 互斥条件：存在互斥使用的资源</span><br><span class="line">- 不可抢占条件：进程获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</span><br><span class="line">- 请求和保持条件：自己有一个资源的同时，对另外一个被占有的资源保持请求，被阻塞，也不会释放自己的资源</span><br><span class="line">- 环路等待条件：存在资源的循环等待链（**必要不充分**）</span><br><span class="line"></span><br><span class="line">发生死锁的情况：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">处理策略：</span><br><span class="line"></span><br><span class="line">- 预防死锁----**最容易实现**</span><br><span class="line">- 避免死锁---**资源的利用率最高**</span><br><span class="line">- 死锁的检测和解除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并发性：检测解除&gt;避免死锁&gt;预防死锁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 预防死锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 破坏互斥条件（不推荐）</span><br><span class="line">- 破坏不剥夺条件</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">- 破坏请求和保持条件：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 破坏循环等待条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 避免死锁</span><br><span class="line"></span><br><span class="line">- 安全序列</span><br><span class="line"></span><br><span class="line">#### 检测和解除![]()</span><br><span class="line"></span><br><span class="line">![image-20231108211057595](https://s2.loli.net/2024/03/11/DYxvZ8dklIg5GOz.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 内存</span><br><span class="line"></span><br><span class="line">- 程序执行之前需要放到内存中才能被CPU处理--缓解CPU和硬盘之间的速度矛盾</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 相对地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 装入方式</span><br><span class="line"></span><br><span class="line">#### 绝对装入</span><br><span class="line"></span><br><span class="line">- 灵活性低、只适用于本机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 可重定位装入（静态重定位）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">适用于固定分区</span><br><span class="line">    可重入就是共享</span><br></pre></td></tr></table></figure><h4 id="动态重定位（动态运行时装入）"><a href="#动态重定位（动态运行时装入）" class="headerlink" title="动态重定位（动态运行时装入）"></a>动态重定位（动态运行时装入）</h4><ul><li>编译就是把高级语言翻译为机器语言</li></ul><h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><p>工作：1.修改相对地址 2.变换外部调用符号</p><ul><li>静态链接</li><li>装入时动态链接</li><li>运行时动态链接</li></ul><h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li><p>OS负责内存空间的分配回收</p></li><li><p>采用多种技术对内存空间扩充</p></li><li><p>实现地址转换，实现逻辑地址和物理地址的转换（三种装入方式）</p></li><li><p>内存保护—保护各个进程互补</p><ul><li><p>设置上下限寄存器</p><ul><li>利用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行判断</li></ul></li></ul></li></ul><h3 id="覆盖和交换"><a href="#覆盖和交换" class="headerlink" title="覆盖和交换"></a>覆盖和交换</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p><strong>早期使用</strong></p><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p><strong>对换区一般采用连续分配</strong>，<strong>换入及换出操作由内存管理模块完成，与程序结构无关</strong></p><p>交换发生在进程或作业之间，覆盖发生在同一进程或作业内</p><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><p>外部碎片和内部碎片是计算机系统中与内存管理相关的两个概念。</p><ol><li><p><strong>外部碎片（External Fragmentation）：</strong></p><ul><li>外部碎片指的是已分配的内存空间中，存在于已分配块之间的一些小块未被使用的内存。虽然总的可用内存可能足够，但由于空闲内存分散在已分配块之间，导致某些时候无法找到足够大的连续内存块来满足需要。这种情况会导致系统效率下降，因为不能有效地利用可用内存。</li></ul></li><li><p><strong>内部碎片（Internal Fragmentation）：</strong></p><ul><li>内部碎片是指已分配的内存块中，由于内存分配算法或数据结构的原因，实际使用的内存空间比分配的内存块大。这意味着分配的内存块中有一部分内存未被有效利用，造成了内存资源的浪费。</li></ul></li></ol><p><strong>例子：</strong></p><p>考虑一个内存中有两个已分配块：块 A 和块 B。块 A 的大小为 30KB，块 B 的大小为 50KB，释放块A。如果一个进程需要分配 40KB 的内存，由于没有足够大的连续内存块，系统无法满足请求，尽管总的可用内存是足够的。这就是外部碎片的例子。</p><p>另外，如果一个进程分配了一个 60KB 的内存块，但实际只使用了其中的 50KB，那么就会有 10KB 的内部碎片，因为有一部分内存被浪费了。</p><p>解决外部碎片和内部碎片的问题通常需要采用不同的内存管理策略和算法，例如使用紧凑算法来减少外部碎片，或者采用更灵活的内存分配策略来减少内部碎片。</p><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>空间可以合并</p><h5 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h5><h5 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h5><h5 id="循环匹配算法"><a href="#循环匹配算法" class="headerlink" title="循环匹配算法"></a>循环匹配算法</h5><p><strong>可重定位分区分配</strong>：采用动态重定位技术的分区分配方式</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><ul><li>递归查询使用</li></ul><h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3><hr><p><strong>段页对比</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.页带来的内部碎片无法消除</span><br><span class="line">2.段优点：1.方便编程 2.分段共享 3.分段保护 4.动态链接 5动态增长   无：1.方便操作</span><br><span class="line">3.页面越大，效率越高，页表长度越小，内碎片越多；页越小，反之；页面大小与磁盘调度关系不大，磁盘调度和扇区关系大</span><br></pre></td></tr></table></figure><hr><h4 id="基本分页存储"><a href="#基本分页存储" class="headerlink" title="基本分页存储"></a>基本分页存储</h4><h5 id="页框"><a href="#页框" class="headerlink" title="页框"></a>页框</h5><ul><li><strong>内存空间</strong>分为大小相等的分区 页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面</li><li>每个页框有页框号&#x3D;页帧号&#x3D;内存块号&#x3D;物理块&#x3D;物理页号  从0开始</li><li>块越大，内&#x2F;外存之间的数据交换效率越高。</li></ul><h5 id="页"><a href="#页" class="headerlink" title="页"></a>页</h5><ul><li><p>将<strong>逻辑地址空间</strong>分为和页框大小相等的<strong>页</strong>or 页面，编号为<strong>页号</strong></p></li><li><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，<strong>进程的页面与内存的页框有一一对应的关系</strong>。<br>各个页面不<strong>必连续存放</strong>，可以放到不相邻的各个页框中。</p></li></ul><h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><ul><li><p><strong>页表通常在PCB中</strong></p></li><li><p>OS为每个进程建立页表，存储在PCB中</p></li><li><p>页面内部连续，内存中离散存放</p></li><li><p>一个进程对应一个页表</p></li><li><p>反应 页和页框的映射</p></li><li><p>页表项大小&#x3D;页号+块号  页号隐藏不占空间  </p></li><li><p>页表项在内存中是连续的，块中不连续</p></li><li><p>虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p></li><li><p>段对用户可见，页对用户不可见</p></li></ul><h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h5><ul><li>逻辑地址A对应的物理地址&#x3D;p号页面在内存中的起始地址+页内偏移量W</li><li></li></ul><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><ul><li><p><strong>TLB、联想存储器、关联存储器、旁路存储器</strong></p></li><li><p><strong>按照内容寻址</strong></p></li><li><p>TLB中只能放页表项的副本，cache中可以放其他数据</p></li><li><p>访问速度比内存快很多的<strong>缓存</strong>  <strong>不是内存</strong></p></li><li><p>用于存放最近的页表项的副本，页被称为慢表</p></li><li><p>加入快表的地址转换过程 局部性原理</p></li><li></li></ul><ul><li>一次和两次</li></ul><h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><ul><li><p>存在的问题</p></li><li><p>建立页表的页表：页目录表</p></li><li></li></ul><ul><li>需要注意的细节</li></ul><p>​n级页表的访存次数是：n+1（没有快表的情况下）</p><h4 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h4><h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><h5 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h5><ul><li>和分页的区别：页大小固定，不需要进行页内偏移量和页长的越界比较</li><li></li></ul><h4 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h4><ul><li><p>段页式管理的段表和分段储存管理的段表不一样，页表一样</p></li><li><p>地址变换过程</p></li></ul><h3 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h3><p><strong>虚拟存储器</strong></p><p>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟存储器允许程序访问比内存更大的地址空间；而不是访问比地址字长更大的空间</span><br></pre></td></tr></table></figure><h4 id="传统管理方式的缺点"><a href="#传统管理方式的缺点" class="headerlink" title="传统管理方式的缺点"></a>传统管理方式的缺点</h4><ul><li>一次性：作业必须一次性装入内存后才能开始运行，导致作业很大无法装入以及多道程序并发度下降</li><li>驻留性：作业被装入内存后会一直驻留在内存中</li></ul><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><p>物理内存大小没变，逻辑上进行扩充</p><ul><li><p>离散性</p></li><li><p>局部性</p></li><li><p>对换性</p></li><li><p>虚拟性</p></li></ul><h4 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h4><p>新增：</p><ul><li>请求调页功能：将缺失页面从外存调入内存</li><li>页面置换：暂时用不到的页面换出外存</li></ul><h5 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h5><h5 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通中断：恢复后执行断点处下一条指令</span><br><span class="line">缺页中断：执行被中断的那一条指令</span><br></pre></td></tr></table></figure><ul><li>当要访问的页面不在内存时，产生<strong>缺页中断</strong>，由操作系统中的<strong>缺页中断处理程序处理中断</strong> </li><li>此时该进程阻塞，进入阻塞队列，调页完成后再将其唤醒，进入就绪队列</li></ul><p>​分配情况</p><ul><li>若有空闲块，则直接进行分配并装入，修改页表中的表项</li><li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</li></ul><p>特性</p><ul><li><p>属于内中断</p></li><li><p>一条指令的执行可能产生多次缺页中断</p></li></ul><p>地址变换机构</p><ul><li>与基本分页的主要区别：访问的信息不在<strong>内存</strong>。需要从<strong>外存</strong>调入；内存空间不够时，由OS将<strong>内存</strong>中暂时不用的换出到<strong>外存</strong></li></ul><ol><li>请求调页</li><li>页面置换</li><li>修改表项</li></ol><p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若<strong>发生缺页，则地址变换步骤</strong>是:<br>查快表(未命中)—―查慢表(发现未调入内存)――调页(调入的页面对应的表项会直接加入快表)―一查快表(命中)―一访问目标内存单元</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>缺页率&#x3D;缺页次数&#x2F;访问次数</p><h5 id="最佳置换算法OPT"><a href="#最佳置换算法OPT" class="headerlink" title="最佳置换算法OPT"></a>最佳置换算法OPT</h5><p>belady提出</p><ul><li>选择淘汰：以后永不使用或者长时间不再被访问，保证最低的缺页率</li><li>当满了后，选择内块中的所有往后寻找最后一个淘汰的页面然后淘汰</li><li><strong>该算法无法实现</strong></li></ul><h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><ul><li>性能很差，会发生Belady现象—–<strong>本质</strong>：局部性原理</li></ul><h5 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h5><ul><li>OPT的逆推</li><li>需要硬件支持，性能好，开销大</li></ul><h5 id="时钟置换算法（CLOCK）（NRU）"><a href="#时钟置换算法（CLOCK）（NRU）" class="headerlink" title="时钟置换算法（CLOCK）（NRU）"></a>时钟置换算法（CLOCK）（NRU）</h5><p><strong>用到了访问位（引用位）+修改位</strong></p><p>访问大于优先</p><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><h5 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h5><ul><li>概念：指请求分页存储管理中给进程分配的物理块的集合。</li><li>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</li><li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</li><li>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</li></ul><p>分配策略：</p><ul><li>固定分配</li><li>可变分配</li></ul><p>置换策略：</p><ul><li>局部置换</li><li>全局置换</li></ul><h5 id="WHEN"><a href="#WHEN" class="headerlink" title="WHEN"></a>WHEN</h5><h5 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h5><h5 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h5><ul><li>分配太多—-降低CPU利用率</li><li>分配太少—-降低整体并发度</li><li>产生原因：系统分配的物理块不够</li><li></li></ul><h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><ul><li>根据工作集的大小确定驻留集的大小</li><li>驻留集&gt;&#x3D;工作集</li></ul><h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li>一组由意义的信息或者数据的集合</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件系统：文件 和 对文件进行操纵管理的软件集合</span><br><span class="line">目的：实现对文件的按名存取和进行存取控制</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上是对外存（辅存）管理</span><br></pre></td></tr></table></figure><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><ul><li>文件名：同一目录不允许有重名文件</li><li>标识符：对用户无可读性</li><li>类型：.xx</li><li>位置：绝对路径和外存地址（OS使用，对用户不可见）</li><li>大小</li><li>创建时间</li><li>上次修改时间</li><li>文件所有者信息</li><li>保护信息</li></ul><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p><strong>内部数据</strong></p><ul><li><p>无结构文件：如txt,由<strong>二进制或字符流</strong>组成，<strong>流式文件</strong></p></li><li><p>有结构文件：如数据库表，由一组<strong>相似的记录</strong>组成，又称<strong>记录式</strong>文件——顺序文件、索引文件、索引顺序文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问基本单位是：记录</span><br><span class="line">记录型文件是具有符号名并在逻辑上有完整意义的记录序列</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开文件系统调用的基本操作是：将文件FCB从外存读到内存</span><br></pre></td></tr></table></figure></li></ul><p><strong>文件之间的组织</strong></p><ul><li>树</li><li>目录：特殊的有结构文件</li></ul><p><strong>OS应该向上提供的功能</strong></p><ul><li>创建文件 create</li><li>删除文件 delete</li><li>读文件 read</li><li>写文件 write</li><li>打开文件 open</li><li>关闭文件 close</li></ul><p><strong>其他文件管理功能</strong></p><ul><li>文件共享</li><li>文件保护</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>无结构文件不讨论</li><li>有结构文件：<ul><li>由一组<strong>相似的记录</strong>组成，又称“记录式文件”。</li><li>每条记录又若干个数据项组成。如:数据库表文件。</li><li>一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID)</li><li>根据记录的长度，可以分为<strong>定长</strong>和可变长记录</li></ul></li></ul><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><ul><li>链式存储：无论定长或者可边长，<strong>无法实现随机存取</strong>，每次只能从第一个记录开始依次往后查找</li><li>顺序存储<ul><li>可变长：无法实现随机存取，每次只能从第一个记录开始依次往后查找</li><li>定长<ul><li>可实现随机存储，记录长度为L，第i个记录的相对位置是：i*L</li><li>采用串结构，无法快速通过关键字检索</li><li>采用顺序结构，可快速通过关键字检索，<strong>顺序文件</strong>指的是物理上顺序，缺点是<strong>增删记录</strong>比较困难</li></ul></li></ul></li></ul><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><ul><li>建立索引表</li><li>索引表:定长记录的顺序文件，<strong>连续存放</strong>   可变长记录文件不连续</li><li>可将多个不同的关键字作为索引号内容</li><li>用于对信息处理的及时性要求比较高的场合</li></ul><p><strong>缺点</strong>：索引表过大降低存储空间利用率</p><h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>二者的集合，与索引文件不同，并不是每个记录建立一个索引表项，<strong>而是一组记录对应一个索引表项，对记录进行分组</strong></p><ul><li>建立多级索引顺序文件，大大减少</li><li></li></ul><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><h4 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h4><ul><li>一个<strong>FCB</strong>就是一个<strong>文件目录项</strong>，<strong>FCB的有序集合称为文件目录</strong></li><li>FCB中包含了文件的<strong>基本信息</strong>（文件名、物理地址、逻辑结构、物理结构等），<strong>存取控制信息</strong>（是否可读可写、禁止访问的用户名单等），<strong>使用信息</strong>（如文件的建立时间、修改时间等）。</li><li>实现了<strong>文件名和文件之间的映射</strong>，让User实现<strong>按名存取</strong></li></ul><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><h5 id="单极目录结构"><a href="#单极目录结构" class="headerlink" title="单极目录结构"></a>单极目录结构</h5><ul><li>支持按名存取，不允许文件冲名</li><li>不适用于多用户系统</li></ul><h5 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h5><ul><li><p>主文件目录：记录用户名</p></li><li><p>用户文件目录：记录用户的文件</p></li><li><p>允许重名；可以实现访问限制；缺点不能进行分类</p></li></ul><h5 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h5><ul><li>树</li><li>从<strong>根目录</strong>出发的路径叫<strong>绝对路径</strong></li><li>引入<strong>当前目录</strong>和<strong>相对路径</strong></li><li>缺点：<strong>不便于实现文件的共享</strong></li></ul><h5 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h5><h4 id="索引节点-FCB的改进"><a href="#索引节点-FCB的改进" class="headerlink" title="索引节点 FCB的改进"></a>索引节点 FCB的改进</h4><ul><li>当找到文件名对应的目录项时，才需要将索引结点<strong>调入内存</strong></li><li>索引结点中记录了文件的<strong>各种信息</strong>，包括文件在外存中的<strong>存放位置</strong>，根据“存放位置”即可找到文件。</li><li>存放在外存中的索引结点称为**“磁盘索引结点”<strong>，当索引结点放入内存后称为</strong>“内存索引结点”。**</li><li>相比之下内存索引结点中需要增加一些信息，比如:<strong>文件是否被修改、此时有几个进程正在访问该文件等</strong>。</li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>要求每个文件在磁盘上占有一组<strong>连续的快</strong></p><ul><li>连续分配方式要求每个文件在磁盘上占有一组连续的块。</li><li>优点:支持顺序访问和直接访问（即随机访问)﹔连续分配的文件在顺序访问时速度最快</li><li>缺点:不方便文件拓展;存储空间利用率低，会产生磁盘碎片</li></ul><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><h5 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h5><ul><li>隐式链接――除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件<strong>第一块的指针</strong>和<strong>最后一块的指针</strong>。</li><li>优点:很方便文件拓展，<strong>不会有碎片问题</strong>，外存利用率高。</li><li>缺点:只支持顺序访问，<strong>不支持随机访问</strong>，<strong>查找效率低</strong>，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><h5 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h5><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点:<strong>文件分配表</strong>的需要占用一定的存储空间。</li></ul><p><strong>考试题目默认隐式链接</strong></p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><ul><li><p>链接方案</p></li><li><p>多层索引</p></li><li><p>混合索引 <strong>unix采用</strong></p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="文件存储管理"><a href="#文件存储管理" class="headerlink" title="文件存储管理"></a>文件存储管理</h3><ul><li><p>空闲表法</p></li><li><p>空闲链表</p></li></ul><p>相关计算：寻址</p><ul><li>计算所在的逻辑块号：当前地址除以磁盘块的大小，商是块号，余数是块内偏移量</li><li>计算索引块中的项目数：磁盘块的大小除以每个地址项（盘块号）的大小，在下面的题目中这个值是$$2^{8}&#x3D;256$$</li><li>查找逻辑块号：在下面的题目中，$$0\sim9$$是直接块，$$10+0\sim10+2^8-1$$是一级间接块，分别对应索引块 428 的 $$0\sim2^8-1$$；$$10+2^8+0\sim10+2^8+2^8-1$$是二级索引第0个地址指向的二级间接块，分别对应索引块 331 的$$0\sim2^8-1$$，等。</li></ul><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1NzQxYTFlMDdhNzI0OTUyMjgwNjdkZTNmZWE0NjRfNTQ3emszeW05clA4UU9udjloOEJOZkRNdHg0bEpUYTdfVG9rZW46S1hZYmJEam1pb1hwa2d4Y2s1cmNVeVF6bjRjXzE3MDM0ODM3MzY6MTcwMzQ4NzMzNl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2YyZjRiNGQ0YWZhYWNiNjBlZjIxNDNjMDlmN2FhYTJfMG1GdzIwSE5QVkQ2Z0dINVJmN3NjeVVYWEtNaUR4cklfVG9rZW46TVZhZmI1SzF5b1RETzl4a0pkbWN3YUltbmtIXzE3MDM0ODM3MzY6MTcwMzQ4NzMzNl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTk3Y2I4YWVkZDQ4ZjFiZDdlZjk3ZWM0ZmU3OTAwNjVfcEZycEVVOWRlNnV0ZUhMcEd1eGE3cUpCd1NYeW4wd2lfVG9rZW46V3FWR2JKTGdNbzRDUnh4TzVLNWN5YmtZbjdlXzE3MDM0ODM3MzY6MTcwMzQ4NzMzNl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU1OTZhMzk5NjU0ZTYxM2ZlMzhhODhiM2I3MDY1MzZfcFBNa24zeTRSUHNCTFRpYXBOZUZSeHVyMHY1UmhhT1BfVG9rZW46VmdWRmJoS1hqb0dBbU94Y3l1NWNncHFjbk5iXzE3MDM0ODM3MzY6MTcwMzQ4NzMzNl9WNA" alt="img"></p><ul><li><strong>位示图法</strong></li><li></li></ul><ul><li>成组链接法</li></ul><h3 id="共享-1"><a href="#共享-1" class="headerlink" title="共享"></a>共享</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>input &amp; output </p><p>分类</p><ul><li>人机交互</li><li>存储设备</li><li>网络通信设备</li></ul><p>速度</p><ul><li>低俗</li><li>中速</li><li>高速</li></ul><p>单位</p><ul><li>块设备：磁盘，可寻址：随机读写</li><li>字符设备：鼠标 不可寻址，输入输出采用中断驱动；打印机  <strong>采用中断驱动</strong></li></ul><p>资源性能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">独占设备静态分配</span><br><span class="line">共享设备动态分配</span><br></pre></td></tr></table></figure><ul><li>独占设备：打印机</li><li>共享设备：磁盘</li><li>虚拟设备</li></ul><h3 id="I-O控制器-AKA电子部件"><a href="#I-O控制器-AKA电子部件" class="headerlink" title="I&#x2F;O控制器 AKA电子部件"></a>I&#x2F;O控制器 AKA电子部件</h3><p><strong>扩展卡或者南桥芯片</strong>内</p><p>组成</p><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><h4 id="DMA-直接存储器存储"><a href="#DMA-直接存储器存储" class="headerlink" title="DMA 直接存储器存储"></a>DMA 直接存储器存储</h4><p>绕过cpu</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>类型</p><ul><li>字节多路通道</li><li>数组选择通道</li><li>数组多路通道</li></ul><p><u>解决“瓶颈”问题的最有效的方法，便是增加设备到主机间的通路，而不增加通道。</u></p><h3 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h3><h4 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h4><ul><li>实现用户交互的接口</li><li>通过调用相关的库函数队设备进行操作，然后翻译成格式化的I&#x2F;O请求通过<strong>系统调用</strong>请求OS内核的服务</li></ul><h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设备独立性是指用户程序独立于具体使用的设备</span><br></pre></td></tr></table></figure><p>AKA:设备无关性软件</p><ul><li>为上层提供系统调用接口：read&#x2F;write</li><li>设备的保护：权限</li><li>差错处理</li><li>设备的分配与回收</li><li>数据缓冲器管理</li><li>建立：逻辑设备名到物理设备名的映射关系   <strong>逻辑设备表****LUT</strong></li></ul><h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><ul><li>负责对硬件设备的具体控制</li><li></li></ul><h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p><strong>只有设备驱动程序和中断处理程序是直接和硬件打交道的</strong></p><h4 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IO重定向：调试过程中输出结果送到屏幕显示，不必正式输出到打印设备</span><br></pre></td></tr></table></figure><h3 id="SPOOLING假脱机技术"><a href="#SPOOLING假脱机技术" class="headerlink" title="SPOOLING假脱机技术"></a>SPOOLING假脱机技术</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学名：在联机情况下实现同时外围操作的技术</span><br></pre></td></tr></table></figure><p><strong>目的</strong>：解决资源互斥和提高设备利用率</p><ul><li><p><strong>脱机</strong>：脱离主机的控制进行的输入&#x2F;输出操作—缓解了CPU与慢速io设备的速度矛盾</p></li><li><p>共享打印机</p></li></ul><p>独占——&gt;共享 </p><h3 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h3><h4 id="分配考虑的因素"><a href="#分配考虑的因素" class="headerlink" title="分配考虑的因素"></a>分配考虑的因素</h4><ul><li>固有属性：独占、共享、虚拟</li><li>分配算法</li><li>安全性</li><li>设备无关性（独立）：只使用逻辑设备名管理设备，映射表；采用统一方式管理设备</li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>在<strong>内存中</strong>建立I&#x2F;O缓冲区，硬件内存比如快表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓冲区管理中最重要的问题是：实现进程访问缓冲区的同步</span><br></pre></td></tr></table></figure><p><strong>单缓冲</strong></p><p>单双工</p><p><strong>双缓冲</strong></p><p>全双工</p><p><strong>循环缓冲</strong></p><p><strong>缓冲池</strong></p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><h4 id="SSTF-最短寻找时间优先"><a href="#SSTF-最短寻找时间优先" class="headerlink" title="SSTF 最短寻找时间优先"></a>SSTF 最短寻找时间优先</h4><h4 id="SCAN扫描算法"><a href="#SCAN扫描算法" class="headerlink" title="SCAN扫描算法"></a>SCAN扫描算法</h4><h4 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h4><h4 id="C-SCAN-循环扫描算法"><a href="#C-SCAN-循环扫描算法" class="headerlink" title="C-SCAN 循环扫描算法"></a>C-SCAN 循环扫描算法</h4><h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><h3 id="减少延迟时间"><a href="#减少延迟时间" class="headerlink" title="减少延迟时间"></a>减少延迟时间</h3><p><strong>转两圈读一圈</strong></p><h4 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h4><h4 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h4><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>​|</p><p>​</p><h4 id="坏块管理"><a href="#坏块管理" class="headerlink" title="坏块管理"></a>坏块管理</h4><p>硬件故障</p><h3 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h3><p><em>image-20231208122123162</em></p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络攻防</title>
      <link href="/2025/01/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
      <url>/2025/01/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="典型案例内容"><a href="#典型案例内容" class="headerlink" title="典型案例内容"></a>典型案例内容</h2><p>黛蛇：蠕虫</p><p>Morris:蠕虫</p><p>温柔、大小姐：木马；</p><p>红色代码、尼姆达和SQL Slammer：远程渗透攻击IIS／MS SQL</p><p>已知漏洞渗透代码来源：Metasploit、Exploit-db、Packetstorm、SecurityFoucs</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>三个查点分类</p><h3 id="网络踩点"><a href="#网络踩点" class="headerlink" title="网络踩点"></a>网络踩点</h3><p>1.有计划有步骤的信息情报搜集 2.了解到目标的网络环境和信息安全状况  3.得到攻击目标剖析图 4.通过对剖析图细致分析，找到薄弱环节，提供指引</p><h3 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h3><p>探测网络，找出更多的连接目标（主机，端口，系统，漏洞）获取类型弱点等，为攻击选择目标，提供通道支持</p><h3 id="漏洞产因："><a href="#漏洞产因：" class="headerlink" title="漏洞产因："></a>漏洞产因：</h3><p>1.系统设计缺陷（internet、TCP&#x2F;IP协议栈 三次握手）2.操作系统内核代码量巨大 3.软件实现的缺陷</p><h3 id="网络查点和扫描踩点的区别"><a href="#网络查点和扫描踩点的区别" class="headerlink" title="网络查点和扫描踩点的区别"></a>网络查点和扫描踩点的区别</h3><p>1.入侵程度：踩点在外围收集信息，查点主动连接查询（会被IDS与日志记录）</p><p>2.针对性、目的性：踩点较大范围，查点有着明确目标</p><h3 id="如何防范网络查点"><a href="#如何防范网络查点" class="headerlink" title="如何防范网络查点"></a>如何防范网络查点</h3><p>1.关闭不必要的网络服务，禁止SMB空会话、共享</p><p>2.加强网络服务的安全配置：限制SMB共享、避免FTP\SMB弱口令以及匿名</p><p>3.放弃使用不安全的网络协议：telnet—&gt;SSH、FTP</p><p>4.避免暴露身份，采用工具改变旗标信息</p><h3 id="网络嗅探"><a href="#网络嗅探" class="headerlink" title="网络嗅探"></a>网络嗅探</h3><p>利用计算机网络接口截获目的地为其他计算机的数据报文，监听网络流中所包含的用户账户密码等信息</p><h3 id="如何防止网络嗅探"><a href="#如何防止网络嗅探" class="headerlink" title="如何防止网络嗅探"></a>如何防止网络嗅探</h3><p>1.采用安全的网络拓扑，将共享式网络升级为交换式网络；交换机上设置vlan分段，分段越细越安全</p><p>2.用静态ARP或者MAC-端口映射表替代动态机制，防止MAC、ARP欺骗</p><p>3.在重要的数据传输点加强安全防范，如网关路由器交换机等</p><p>4.避免使用明文传输口令或者网络协议，telnet-ssh；IPSEC-TLS</p><h3 id="流重组"><a href="#流重组" class="headerlink" title="流重组"></a>流重组</h3><p>将同属于一个TCP&#x2F;UDP会话的IP包负载按序重新组装，还原应用层数据的过程</p><h3 id="拒绝服务攻击DOS"><a href="#拒绝服务攻击DOS" class="headerlink" title="拒绝服务攻击DOS"></a>拒绝服务攻击DOS</h3><p>DOS攻击是指利用网络协议漏洞或其它系统以及应用软件漏洞耗尽被攻击目标CPU、内存、带宽、磁盘等系统资源，使得被攻击的计算机网络无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式</p><h3 id="DoS-原理"><a href="#DoS-原理" class="headerlink" title="DoS 原理"></a>DoS 原理</h3><p>攻击者向服务器发送众多的带有虚假地址的请求，服务器发送回复信息后等待回传信息。由于地址是伪造的，所以服务器一直等不到回传的消息，分配给这次请求的资源就始终没有被释放。当服务器等待一定的时间后，连接会因超时而被切断，攻击者会再度传送新的一批请求，在这种反复发送伪地址请求的情况下，服务器资源最终会被耗尽。</p><h3 id="DOS种类"><a href="#DOS种类" class="headerlink" title="DOS种类"></a>DOS种类</h3><p>1.资源耗尽型：贷款、磁盘、cpu、内存资源</p><p>2.配置修改型：注册表</p><p>3.基于系统缺陷：口令输入过多导致账户锁定</p><p>4.物理实体破坏型</p><h3 id="DOS攻击的基本形式"><a href="#DOS攻击的基本形式" class="headerlink" title="DOS攻击的基本形式"></a>DOS攻击的基本形式</h3><p>1.服务过载</p><p>2.消息流：网络风暴</p><p>3.信号接地：关闭网络电缆接地</p><p>4.粘住攻击：tcp半开</p><h3 id="应付DDoS攻击的策略"><a href="#应付DDoS攻击的策略" class="headerlink" title="应付DDoS攻击的策略"></a>应付DDoS攻击的策略</h3><h3 id="Bot"><a href="#Bot" class="headerlink" title="Bot"></a>Bot</h3><p>机器人(Robot)的缩写，是一段可以自动执行预先设定功能，可以被控制，具有一定人工智能的程序。通常带有恶意代码的Bot被秘密植入受控计算机，主动连接服务器接受控制指令，并依照指令完成相应功能。</p><h3 id="Zombie"><a href="#Zombie" class="headerlink" title="Zombie"></a>Zombie</h3><p>被包含恶意代码的Bot感染或能被远程控制的计算机，又名僵尸计算机。</p><h3 id="DOS发展趋势"><a href="#DOS发展趋势" class="headerlink" title="DOS发展趋势"></a>DOS发展趋势</h3><p>重放追踪技术升级</p><p>攻击过程日趋智能化</p><p>攻击手段日趋多样化</p><h3 id="Web应用程序三层架构"><a href="#Web应用程序三层架构" class="headerlink" title="Web应用程序三层架构"></a>Web应用程序三层架构</h3><p>表示层、业务逻辑层、数据层</p><h3 id="针对web不同架构的攻击"><a href="#针对web不同架构的攻击" class="headerlink" title="针对web不同架构的攻击"></a>针对web不同架构的攻击</h3><h3 id="Web服务器平台中的安全漏洞"><a href="#Web服务器平台中的安全漏洞" class="headerlink" title="Web服务器平台中的安全漏洞"></a>Web服务器平台中的安全漏洞</h3><p>1.数据驱动的远程代码执行安全漏洞：缓冲区溢出、格式化字符串</p><p>2.服务器功能扩展模块漏洞</p><p>3.样本文件安全漏洞</p><p>4.源代码泄露</p><p>5.资源解析攻击</p><h3 id="Web应用程序安全威胁类型"><a href="#Web应用程序安全威胁类型" class="headerlink" title="Web应用程序安全威胁类型"></a>Web应用程序安全威胁类型</h3><ol><li>针对认证机制的攻击</li><li>针对授权机制的攻击</li><li>客户端攻击 </li><li>命令执行攻击</li><li>信息暴露 </li><li>逻辑攻击</li></ol><h3 id="攻击Web数据内容"><a href="#攻击Web数据内容" class="headerlink" title="攻击Web数据内容"></a>攻击Web数据内容</h3><ol><li>安全敏感信息泄露</li><li>网站内容篡改</li><li>不良信息内容上传</li></ol><h3 id="如何防范SQL注入"><a href="#如何防范SQL注入" class="headerlink" title="如何防范SQL注入"></a>如何防范SQL注入</h3><ol><li>使用类型安全的参数编码机制</li><li>凡是来自外部的用户输入，必须进行完备检查</li><li>将动态的SQL语句替换为存储过程、预编译SQL或ADO命令对象</li><li>加强SQL数据库服务器的配置和连接</li></ol><p>1.服务器端防范措施：限制、拒绝、净化</p><ul><li>输入验证</li><li>输出净化：HTMLEncode（）</li><li>消除危险的输入点</li></ul><p>2.客户端方案措施</p><ul><li>提高浏览器安全等级</li><li>关闭Cookie，或者将Cookie设置为只读</li><li>使用安全的浏览器</li></ul><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>用户向计算机系统以一种安全的方式提交自己的身份证明，然后由系统确认用户的身份是否属实，最终决定拒绝用户或者赋予一定的权限’</p><h3 id="Mimikatz获取Windows密码的原理"><a href="#Mimikatz获取Windows密码的原理" class="headerlink" title="Mimikatz获取Windows密码的原理"></a>Mimikatz获取Windows密码的原理</h3><h3 id="口令的防护"><a href="#口令的防护" class="headerlink" title="口令的防护"></a>口令的防护</h3><p>1.选择安全密码：足够长度、大小写…</p><p>2.防止口令猜测攻击</p><ul><li>硬盘分区采用NTFS格式</li><li>正确设置和管理账户</li><li>禁止不需要的服务</li><li>关闭不用的端口</li><li>禁止建立空连接</li></ul><p>3.设置安全策略</p><ul><li>强制密码历史</li><li>密码最长最短使用期限</li><li>密码长度最小值</li><li>密码必须符合复杂性要求</li></ul><h3 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h3><p>经过存储介质和网络传播，从一台PC到另外一台PC，未经授权认证破坏计算机系统完整性的程序或者代码，使得计算机按照攻击者意图执行以达到恶意目标的指令集。</p><h3 id="如何防范IP源地址欺骗"><a href="#如何防范IP源地址欺骗" class="headerlink" title="如何防范IP源地址欺骗"></a>如何防范IP源地址欺骗</h3><p>1.使用随机化的初始序列号，避免远程盲攻击</p><p>2.使用网络层安全传输协议IPsec</p><p>3.避免采用基于IP地址的信任策略，以基于加密算法的用户身份认证机制来替代</p><p>4.在路由器和网关上实施包检查和过滤，入站出站过滤</p><p>5.真实源IP地址验证</p><h3 id="如何防止ARP欺骗"><a href="#如何防止ARP欺骗" class="headerlink" title="如何防止ARP欺骗"></a>如何防止ARP欺骗</h3><ol><li>静态绑定关键主机IP地址与MAC地址映射关系</li><li>使用VLAN虚拟子网细分网络拓扑</li><li>加密传输数据以降低ARP欺骗攻击的危害后果</li><li>使用ARP防范工具：ARP防火墙</li></ol><h3 id="TCP-IP协议栈各层的安全防护"><a href="#TCP-IP协议栈各层的安全防护" class="headerlink" title="TCP&#x2F;IP协议栈各层的安全防护"></a>TCP&#x2F;IP协议栈各层的安全防护</h3><p>1.网络接口层：主要防护的是网路嗅探</p><ul><li>监听检测</li><li>vlan细分结构</li><li>关键网关防护</li><li>加密通信协议</li></ul><p>2.互联层</p><ul><li>检测过滤各种欺骗</li><li>防火墙、关键网关</li><li>IP-MAC静态映射表、IPsec加密</li></ul><p>3.传输层</p><p>加密传输安全控制机制：身份认证、访问控制</p><p>4.应用层</p><p>加密；认证；数字签名；https；IDS</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>DNS注册信息Whois查询（3R信息）：SamSpade, SuperScan</p><p>DNS查询域名映射工具：nslookup&#x2F;dig</p><p>Whois客户程序： IP whois查询</p><p>网络入侵检测系统&#x2F;网络入侵防御系统: Snort</p><p>网络路由侦察：: traceroute&#x2F;tracert  虚假响应信息: RotoRouter</p><p>nmap（nmap FE, Zenmap）、Superscan：扫描</p><table><thead><tr><th align="center">技术类型</th><th align="center">经典工具</th></tr></thead><tbody><tr><td align="center">操作系统主动探测技术</td><td align="center">nmap  -O, queso</td></tr><tr><td align="center">操作系统被动辨识技术</td><td align="center">P0f, siphon</td></tr><tr><td align="center">网络服务主动探测技术</td><td align="center">nmap -sV,</td></tr><tr><td align="center">网络服务被动辨识技术</td><td align="center">PADS</td></tr><tr><td align="center">系统扫描检测工具</td><td align="center">scanlogd, PortSentry, Genius</td></tr><tr><td align="center">网络入侵检测系统:</td><td align="center">Snort中的portscan检测插件</td></tr><tr><td align="center">UDP端口扫描</td><td align="center">udp-scan nmap wups scanline:</td></tr><tr><td align="center">主机扫描监测工具</td><td align="center">Scanlogd</td></tr><tr><td align="center">扫描</td><td align="center">nmap（nmap FE, Zenmap）、Superscan</td></tr><tr><td align="center">被动操作系统识别技术流量监听(开放端口):</td><td align="center">tcpdump</td></tr><tr><td align="center">网络服务特征被动匹配和识别</td><td align="center">PADS</td></tr><tr><td align="center">网络服务旗标抓取和探测</td><td align="center">nmap -sV</td></tr><tr><td align="center">漏洞扫描</td><td align="center">ISS、SATAN、Nessus、Xscan（冰河黄鑫）、OpenVAs Greenbone</td></tr><tr><td align="center">网络查点：网络服务旗标抓取</td><td align="center">telnet netcat</td></tr><tr><td align="center">查点</td><td align="center">net view\nbtscan\nltest\nbtstat</td></tr><tr><td align="center">网络嗅探</td><td align="center">wireshark, Sniffer Pro，BPF&#x2F;libpcap，NPF&#x2F;WinpcapSnort\、dsniff、sniffit和linux_sniffernNPF&#x2F;winpcap&#x2F;windumpnSnifferPronButtsniffer、NetMon、Network Associates Sniffer</td></tr><tr><td align="center">抓包</td><td align="center">Tcpdump</td></tr><tr><td align="center">网络流重组</td><td align="center">nstreams, snort</td></tr><tr><td align="center">高层统计和摘要分析</td><td align="center">Netflow, RRDTools</td></tr><tr><td align="center">Web应用安全辅助分析工具</td><td align="center">Burp Suite，Fiddler，WebScarab，，Paros Proxy和SPIKE Proxy</td></tr><tr><td align="center">结合爬虫的评估与漏洞探测工具</td><td align="center">Whisker与Libwhisker ／Nikto ／N-Stealth</td></tr><tr><td align="center">黑客渗透测试工具</td><td align="center">NBSI、HDSI、Domain</td></tr><tr><td align="center">商业Web应用安全评估系统和漏洞扫描器</td><td align="center">Nessus、IBM－Appscan、HP WebInspect、WVS、极光、Jsky</td></tr><tr><td align="center">自动化SQL注入漏洞发现</td><td align="center">Wposion、nmieliekoek.pl</td></tr><tr><td align="center">自动化SQL注入测试</td><td align="center">SPIKE Proxy工具nSPI Toolkit工具包中的“SQL Injector”工具</td></tr><tr><td align="center">国内sql黑客界工具</td><td align="center">NBSI、HDSI、阿D注入工具、CSC、WED…、Pangolin</td></tr><tr><td align="center">网马</td><td align="center">CHM网马、Icefox冰狐、MS06-014网马, ANI网马：熊猫烧香</td></tr><tr><td align="center">网页木马追踪和定位系统</td><td align="center">MwHunter</td></tr><tr><td align="center">网页木马、植入恶意代码采集系统</td><td align="center">MwFetcher</td></tr><tr><td align="center">常用的口令获取及破解工具</td><td align="center">L0phtcrack、Mimikatz、NTSweep、NTCrack、PWDump……Rainbow tables、Mimikatz</td></tr><tr><td align="center">病毒</td><td align="center">CIH、Melissa</td></tr><tr><td align="center">蠕虫</td><td align="center">ILOVEYOU、Code Red、SQL Slammer、WORM_LOVGATE.AE、PE_LOOKED.ID-O</td></tr><tr><td align="center">木马</td><td align="center">QAZ、冰河，NetBull、广外女生、蓝色火焰</td></tr><tr><td align="center">恶意代码工具</td><td align="center">TCP View、Regmon、Filemon、InstallRite</td></tr><tr><td align="center">后门</td><td align="center">灰鸽子</td></tr><tr><td align="center">原始报文伪造技术</td><td align="center">Libnet库 for C、Scapy库 for Pythono、Netwox&#x2F;Netwag</td></tr><tr><td align="center">IP源地址欺骗</td><td align="center">Netwox、Nmap</td></tr><tr><td align="center">无线踩点软件</td><td align="center">NetStumbler、Kismet</td></tr><tr><td align="center">Aircrack-ng 破解WEP密钥</td><td align="center">Aircrack-ng</td></tr><tr><td align="center">oWindows平台无线Sniffer软件</td><td align="center">OmniPeek Personal WinAirCrack&#x2F;Airodump</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
